<!DOCTYPE html>
<html lang="en"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Wind Turbine 3D</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }
        #controls-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            max-width: 350px;
            max-height: 90vh;
            overflow-y: auto;
        }
        #controls-panel.minimized #controls-content {
            display: none;
        }
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #667eea;
        }
        h2 {
            color: #333;
            font-size: 1.5em;
            margin: 0;
        }
        .minimize-btn {
            background: #667eea;
            color: white;
            border: none;
            border-radius: 4px;
            width: 30px;
            height: 30px;
            cursor: pointer;
            font-size: 1.2em;
            line-height: 1;
        }
        .minimize-btn:hover {
            background: #5568d3;
        }
        .control-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            color: #555;
            font-weight: 500;
        }
        input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }
        .value-display {
            display: inline-block;
            min-width: 50px;
            text-align: right;
            font-weight: bold;
            color: #667eea;
        }
        .info-text {
            font-size: 0.85em;
            color: #777;
            margin-top: 3px;
        }
        #stats {
            position: absolute;
            top: 20px;
            left: calc(100vw - 240px);
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            min-width: 200px;
        }
        #stats h3 {
            margin-bottom: 10px;
            color: #333;
            font-size: 1.2em;
        }
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid #eee;
        }
        .stat-row:last-child {
            border-bottom: none;
        }
        .stat-label {
            color: #666;
        }
        .stat-value {
            font-weight: bold;
            color: #667eea;
        }
        #legend {
            position: absolute;
            top: calc(100vh - 220px);
            left: calc(100vw - 240px);
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        #legend h3 {
            margin-bottom: 10px;
            color: #333;
            font-size: 1.1em;
        }
        .legend-gradient {
            height: 30px;
            background: linear-gradient(to right, 
                #0000ff, #0080ff, #00ffff, #00ff00, 
                #ffff00, #ff8000, #ff0000, #8b0000);
            border-radius: 5px;
            margin-bottom: 8px;
        }
        .legend-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.85em;
            color: #666;
        }
        #plot-panel {
            position: absolute;
            top: calc(100vh - 640px);
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            max-width: 90vw;
            max-height: 90vh;
            width: 800px;
            height: 600px;
            resize: both;
            overflow: auto;
        }
        #spanwise-panel {
            position: absolute;
            top: 120px;
            left: calc(100vw - 620px);
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            max-width: 90vw;
            max-height: 90vh;
            width: 600px;
            height: 700px;
            resize: both;
            overflow: auto;
        }
        #spanwise-panel.minimized {
            width: auto !important;
            height: auto !important;
            max-width: none !important;
            max-height: none !important;
            resize: none;
            overflow: hidden !important;
        }
        #spanwise-panel.minimized #spanwise-content {
            display: none;
            height: 0 !important;
            overflow: hidden !important;
        }
        #plot-panel.minimized {
            width: auto !important;
            height: auto !important;
            max-width: none !important;
            max-height: none !important;
            resize: none;
            overflow: hidden !important;
        }
        #plot-panel.minimized #plot-content {
            display: none;
            height: 0 !important;
            overflow: hidden !important;
        }
        #plot-panel.minimized .trace-tab-content {
            height: 0 !important;
        }
        #plot-panel.minimized .plot-header {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }
        .plot-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #667eea;
        }
        .plot-title {
            color: #333;
            font-size: 1.2em;
            font-weight: bold;
        }
        .plot-controls {
            margin-bottom: 15px;
        }
        .trace-tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
            border-bottom: 2px solid #ddd;
        }
        .trace-tab-btn {
            padding: 8px 16px;
            background: none;
            border: none;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            font-size: 0.95em;
            color: #666;
            transition: all 0.2s;
        }
        .trace-tab-btn:hover {
            color: #333;
            background: rgba(102, 126, 234, 0.1);
        }
        .trace-tab-btn.active {
            color: #667eea;
            border-bottom-color: #667eea;
            font-weight: bold;
        }
        .trace-tab-content {
            display: none;
            height: calc(100% - 120px);
            overflow-y: auto;
        }
        .trace-tab-content.active {
            display: block;
        }
        .spanwise-tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
            border-bottom: 2px solid #ddd;
        }
        .spanwise-tab-btn {
            padding: 8px 16px;
            background: none;
            border: none;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            font-size: 0.95em;
            color: #666;
            transition: all 0.2s;
        }
        .spanwise-tab-btn:hover {
            color: #333;
            background: rgba(102, 126, 234, 0.1);
        }
        .spanwise-tab-btn.active {
            color: #667eea;
            border-bottom-color: #667eea;
            font-weight: bold;
        }
        .spanwise-tab-content {
            display: none;
        }
        .spanwise-tab-content.active {
            display: block;
        }
        .chart-container {
            margin-bottom: 20px;
            height: 300px;
        }
        .chart-with-fourier {
            display: flex;
            flex-direction: column;
            gap: 15px;
            height: 100%;
        }
        .chart-with-fourier .chart-container {
            flex: 1;
            min-height: 250px;
        }
        .fourier-summary {
            background: #f9f9f9;
            padding: 15px;
            border-radius: 8px;
            max-height: 300px;
            overflow-y: auto;
        }
        input[type="checkbox"] {
            margin-right: 5px;
        }
        select {
            width: 100%;
            padding: 5px;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
        #display-toggle {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 12px 24px;
            background: rgba(102, 126, 234, 0.95);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            cursor: pointer;
            box-shadow: 0 4px 16px rgba(0,0,0,0.3);
            z-index: 10000;
            transition: all 0.3s;
        }
        #display-toggle:hover {
            background: rgba(102, 126, 234, 1);
            transform: scale(1.05);
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="controls-panel">
        <div class="panel-header">
            <h2>üå¨Ô∏è Wind Turbine Controls</h2>
            <button class="minimize-btn" id="minimize-btn">+</button>
        </div>
        <div id="controls-content">
            <div class="control-group">
                <label>Wind Speed: <span class="value-display" id="wind-speed-value">10.0</span> m/s</label>
                <input type="range" id="wind-speed" min="0" max="25" value="10" step="0.5">
            </div>
            
            <div class="control-group">
                <label>Shaft Speed: <span class="value-display" id="shaft-speed-value">10.0</span> RPM</label>
                <input type="range" id="shaft-speed" min="0" max="20" value="10" step="0.5">
            </div>
            
            <div class="control-group">
                <label>
                    <input type="checkbox" id="pause-rotation"> Pause Rotation
                </label>
            </div>
            
            <div class="control-group">
                <label>Manual Rotation: <span class="value-display" id="manual-rotation-value">0.0</span>¬∞</label>
                <input type="range" id="manual-rotation" min="0" max="360" value="0" step="0.1">
                <div class="info-text">Manual rotor angle control (when paused)</div>
            </div>
            
            <div class="control-group">
                <label>Blade Pitch: <span class="value-display" id="blade-pitch-value">0.0</span>¬∞</label>
                <input type="range" id="blade-pitch" min="-10" max="30" value="0" step="1">
                <div class="info-text">Visual pitch angle</div>
            </div>
            
            <div class="control-group">
                <label>Number of Blades: <span class="value-display" id="num-blades-value">3</span></label>
                <input type="range" id="num-blades" min="1" max="20" value="3" step="1">
            </div>
            
            <div class="control-group">
                <label>Wind Direction: <span class="value-display" id="yaw-value">0.0</span>¬∞</label>
                <input type="range" id="yaw" min="-180" max="180" value="0" step="5">
                <div class="info-text">Wind yaw angle (turbine stays fixed)</div>
            </div>
            
            <div class="control-group">
                <label>Inflow Angle: <span class="value-display" id="inflow-value">0.0</span>¬∞</label>
                <input type="range" id="inflow" min="-20" max="20" value="0" step="1">
                <div class="info-text">Vertical wind component</div>
            </div>
            
            <div class="control-group">
                <label>
                    <input type="checkbox" id="show-axes"> Show Axes (RGB = XYZ)
                </label>
                <div class="info-text">Red=X, Green=Y, Blue=Z</div>
            </div>
            
            
            <div class="control-group">
                <label>
                    <input type="checkbox" id="wind-farm-mode"> Wind Farm Mode (5 Turbines)
                </label>
                <div class="info-text">Multiple turbines with speed variation</div>
            </div>
            
            <div class="control-group">
                <label>
                    <input type="checkbox" id="show-heatmap" checked=""> Show Load Heatmap
                </label>
                <div class="info-text">Color-coded blade loads</div>
            </div>
            
            <div class="control-group">
                <label>
                    <input type="checkbox" id="remove-mean"> Remove 0P (Mean Component)
                </label>
                <div class="info-text">Show only alternating loads</div>
            </div>
            
            <div class="control-group">
                <label>
                    <input type="checkbox" id="show-vectors"> Show Force Vectors
                </label>
            </div>
            
            <div class="control-group">
                <label>Vector Scale: <span class="value-display" id="vector-scale-value">0.100</span></label>
                <input type="range" id="vector-scale" min="0.001" max="1.0" value="0.1" step="0.001">
            </div>
            
            <div class="control-group">
                <label>Vector Display:</label>
                <select id="vector-mode">
                    <option value="all">All Blades</option>
                    <option value="single">Single Blade</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>Angular Resolution: <span class="value-display" id="angular-res-value">1.0</span>¬∞</label>
                <input type="range" id="angular-resolution" min="0.333" max="15" value="1" step="0.01">
                <div class="info-text">Sampling resolution (lower = more detail)</div>
            </div>
        </div>
    </div>
    
    <div id="stats">
        <h3>üìä Statistics</h3>
        <div class="stat-row">
            <span class="stat-label">Max Load:</span>
            <span class="stat-value" id="max-load">73.14</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Avg AoA:</span>
            <span class="stat-value" id="avg-aoa">44.5</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Tip Speed:</span>
            <span class="stat-value" id="tip-speed">20.9</span>
        </div>
    </div>
    
    <div id="legend">
        <h3>Load Scale</h3>
        <div class="legend-gradient"></div>
        <div class="legend-labels">
            <span>Low</span>
            <span>High</span>
        </div>
    </div>
    
    <div id="spanwise-panel">
        <div class="plot-header">
            <div class="plot-title">üìê Spanwise Analysis</div>
            <button class="minimize-btn" id="minimize-spanwise-btn">‚àí</button>
        </div>
        <div id="spanwise-content">
            <div class="spanwise-tabs">
                <button class="spanwise-tab-btn active" data-tab="loading">Spanwise Loading</button>
                <button class="spanwise-tab-btn" data-tab="section">Section Analysis</button>
            </div>
            
            <div id="loading-tab" class="spanwise-tab-content active">
                <div style="padding: 10px;">
                    <p style="font-size: 0.9em; margin: 5px 0;">Thrust distribution along blade span at different azimuth angles</p>
                    <canvas id="spanwise-chart"></canvas>
                </div>
            </div>
            
            <div id="section-tab" class="spanwise-tab-content">
                <div style="padding: 10px;">
                    <p style="font-size: 0.9em; margin: 5px 0;">Airfoil section and velocity vectors (at radial station from Load Traces)</p>
                    <canvas id="section-chart"></canvas>
                    <div id="section-info" style="margin-top: 10px; font-size: 0.85em; background: #f5f5f5; padding: 8px; border-radius: 4px;">
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                            <div><strong>Azimuth:</strong> <span id="section-azimuth">0¬∞</span></div>
                            <div><strong>AoA:</strong> <span id="section-aoa">0¬∞</span></div>
                            <div><strong>V_total:</strong> <span id="section-vtotal">0 m/s</span></div>
                            <div><strong>V_tangential:</strong> <span id="section-vtang">0 m/s</span></div>
                            <div><strong>V_normal:</strong> <span id="section-vnorm">0 m/s</span></div>
                            <div><strong>Thrust:</strong> <span id="section-thrust">0 N</span></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div id="plot-panel">
        <div class="plot-header">
            <div class="plot-title">üìä Load Traces</div>
            <button class="minimize-btn" id="minimize-plot-btn">+</button>
        </div>
        <div id="plot-content">
            <div class="plot-controls">
                <label>Radial Station (% span): <span class="value-display" id="station-value">50</span></label>
                <input type="range" id="radial-station" min="10" max="95" value="50" step="5">
            </div>
            
            <div class="trace-tabs">
                <button class="trace-tab-btn active" data-tab="thrust">Thrust</button>
                <button class="trace-tab-btn" data-tab="moment-y">Yawing Moment (M_y)</button>
                <button class="trace-tab-btn" data-tab="moment-z">Nodding Moment (M_z)</button>
                <button class="trace-tab-btn" data-tab="debug">Debug</button>
            </div>
            
            <div id="thrust-tab" class="trace-tab-content active">
                <div class="chart-with-fourier">
                    <div class="chart-container">
                        <canvas id="lift-chart"></canvas>
                    </div>
                    <div class="fourier-summary">
                        <h4 style="margin-top: 0; font-size: 1em;">Thrust Harmonics</h4>
                        <div id="fourier-thrust-content"></div>
                    </div>
                </div>
            </div>
            
            <div id="moment-y-tab" class="trace-tab-content">
                <div class="chart-with-fourier">
                    <div class="chart-container">
                        <canvas id="moment-y-chart"></canvas>
                    </div>
                    <div class="fourier-summary">
                        <h4 style="margin-top: 0; font-size: 1em;">Yawing Moment Harmonics</h4>
                        <div id="fourier-moment-y-content"></div>
                    </div>
                </div>
            </div>
            
            <div id="moment-z-tab" class="trace-tab-content">
                <div class="chart-with-fourier">
                    <div class="chart-container">
                        <canvas id="moment-z-chart"></canvas>
                    </div>
                    <div class="fourier-summary">
                        <h4 style="margin-top: 0; font-size: 1em;">Nodding Moment Harmonics</h4>
                        <div id="fourier-moment-z-content"></div>
                    </div>
                </div>
            </div>
            
            <div id="debug-tab" class="trace-tab-content">
                <button id="generate-debug" style="margin-bottom: 10px; padding: 8px 16px; background: #667eea; color: white; border: none; border-radius: 4px; cursor: pointer;">Generate Debug Data (2 Blades, 2 Revolutions)</button>
                <div id="debug-output" style="font-family: monospace; font-size: 0.85em;"></div>
            </div>
        </div>
    </div>

    <button id="display-toggle">üì∫ Hide Displays</button>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
    
    <!-- Photo Rendering Mode Dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/RGBELoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/pmrem/PMREMGenerator.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/BokehPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/FXAAShader.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        scene.fog = null; // No fog in default mode
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(50, 30, 50);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // ready for photo mode
        document.getElementById('canvas-container').appendChild(renderer.domElement);
        
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(50, 50, 50);
        directionalLight.castShadow = true;
        
        // Configure shadow camera for proper coverage
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.left = -100;
        directionalLight.shadow.camera.right = 100;
        directionalLight.shadow.camera.top = 100;
        directionalLight.shadow.camera.bottom = -100;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 200;
        directionalLight.shadow.bias = -0.0001;
        
        scene.add(directionalLight);
        
        // Debug axes
        const sceneAxes = new THREE.AxesHelper(30);
        sceneAxes.visible = false;
        scene.add(sceneAxes);
        
        const rotorAxes = new THREE.AxesHelper(25);
        rotorAxes.visible = false;
        
        const nacelleAxes = new THREE.AxesHelper(5);
        nacelleAxes.visible = false;
        
        // --- Photo mode config/state ---
        const PhotoConfig = {
            HDRI_URL: "https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/2k/kloppenheim_06_2k.hdr",
            bloomStrength: 0.35,
            bloomRadius: 0.8,
            bloomThreshold: 0.85,
            bokehFocusNear: 15,
            bokehFocusFar: 80,
            bokehAperture: 0.00001,   // Minimal blur
            bokehMaxBlur: 0.0005,     // Almost no blur
            useBokeh: false,          // Disable bokeh by default
        };
        
        let isPhotoMode = false;
        let composer = null, renderPass = null, bloomPass = null, bokehPass = null, fxaaPass = null;
        let pmremGen = null, envMap = null;
        let skyboxMesh = null;  // For scalable background
        let cloudPlane = null;  // Animated cloud layer
        let cloudOffset = 0;    // For scrolling clouds
        let ground = null;      // Ground plane
        
        // remember "simple" look to restore
        const OriginalLook = {
            background: scene.background ? scene.background.clone() : null,
            fog: scene.fog || null,
            dirLightIntensity: directionalLight.intensity,
        };
        
        // cache original materials to restore later
        const OriginalMats = new Map(); // mesh => material
        function cacheMaterial(mesh){
            if (!OriginalMats.has(mesh)) OriginalMats.set(mesh, mesh.material);
        }
        
        // Animation frame counter
        let frameCount = 0;
        
        // Turbine parameters
        const turbineParams = {
            windSpeed: 10,
            shaftSpeed: 10,
            bladePitch: 0,
            numBlades: 3,
            yawAngle: 0,
            inflowAngle: 0,
            towerHeight: 30,
            bladeRadius: 20,
            hubRadius: 1.5,
            radialStation: 0.5,  // 0 to 1 (fraction of span)
            showVectors: false,  // Show force vectors
            vectorScale: 0.1,    // Force vector scale factor
            vectorMode: 'all',   // 'all' or 'single' blade
            showHeatmap: true,   // Show load heatmap on blades
            angularResolution: 1.0,  // Angular resolution in degrees (0.333 to 15)
            paused: false,       // Pause rotation
            manualRotation: 0,   // Manual rotation angle in degrees
            windFarmMode: false, // Enable multiple turbines
            farmTurbineCount: 5, // Total turbines in wind farm
            speedVariation: 0.05, // ¬±5% speed variation
            removeMean: false    // Remove 0P (mean) component from loads
        };
        
        // Data history for plotting
        // After fast Fourier, traces will scroll continuously
        const plotData = {
            time: [],           // Now represents continuous time, not azimuth
            bladeLift: [],
            bladeMomentY: [],
            bladeMomentZ: [],
            totalLift: [],
            totalMomentY: [],
            totalMomentZ: [],
            timeValue: 0,       // Continuous time counter (in radians)
            tdcMarkers: []      // Track when blade 1 hits top dead center (azimuth = 0)
        };
        
        // Fourier analysis data collection
        const fourierData = {
            collecting: false,
            startAzimuth: 0,
            bladeLift: [],
            bladeMomentY: [],
            bladeMomentZ: [],
            totalLift: [],
            totalMomentY: [],
            totalMomentZ: [],
            complete: false,
            fastMode: false,  // Use fast collection for first revolution
            lastCollectionTime: 0,
            samplingInterval: 0,
            speedMultiplier: 5  // Speed up rotation by this factor during fast collection
        };
        
        // Wind farm additional turbines
        let additionalTurbines = [];
        
        let timeCounter = 0;
        
        function initPlotData() {
            plotData.time = [];
            plotData.bladeLift = [];
            plotData.bladeMomentY = [];
            plotData.bladeMomentZ = [];
            plotData.totalLift = [];
            plotData.totalMomentY = [];
            plotData.totalMomentZ = [];
            plotData.timeValue = 0;
            plotData.tdcMarkers = [];
            for (let i = 0; i < turbineParams.numBlades; i++) {
                plotData.bladeLift[i] = [];
                plotData.bladeMomentY[i] = [];
                plotData.bladeMomentZ[i] = [];
            }
            timeCounter = 0;
        }
        
        initPlotData();
        
        // Reset Fourier analysis collection
        function resetFourierCollection() {
            fourierData.collecting = false;
            fourierData.complete = false;
            fourierData.bladeLift = [];
            fourierData.bladeMomentY = [];
            fourierData.bladeMomentZ = [];
            fourierData.totalLift = [];
            fourierData.totalMomentY = [];
            fourierData.totalMomentZ = [];
            fourierData.fastMode = true; // Next collection will be fast
        }
        
        // Start Fourier collection at current azimuth
        function startFourierCollection() {
            const currentAzimuthRad = rotorGroup.rotation.x;
            fourierData.startAzimuth = currentAzimuthRad;
            fourierData.collecting = true;
            fourierData.complete = false;
            fourierData.bladeLift = [];
            fourierData.bladeMomentY = [];
            fourierData.bladeMomentZ = [];
            fourierData.totalLift = [];
            fourierData.totalMomentY = [];
            fourierData.totalMomentZ = [];
            
            // Set sampling interval based on mode
            if (fourierData.fastMode) {
                // Fast mode: collect ~36-72 points per revolution (5-10 degree steps)
                fourierData.samplingInterval = Math.max(5, turbineParams.angularResolution);
            } else {
                // Normal mode: use current angular resolution
                fourierData.samplingInterval = turbineParams.angularResolution;
            }
            
            fourierData.lastCollectionTime = 0;
        }
        
        // Ground plane with shadow receiving and high-quality grass texture WITH UNDULATION
        const groundGeometry = new THREE.PlaneGeometry(1000, 1000, 150, 150); // High detail segments
        const vertices = groundGeometry.attributes.position.array;
        
        // Add rolling terrain undulation (same as photo mode)
        for (let i = 0; i < vertices.length; i += 3) {
            const x = vertices[i];
            const z = vertices[i + 1];
            const distance = Math.sqrt(x * x + z * z);
            
            // Multiple sine waves for natural-looking hills
            let height = Math.sin(x * 0.01) * 8 + Math.cos(z * 0.012) * 6;
            height += Math.sin(x * 0.03 + z * 0.02) * 3;
            height += Math.sin(distance * 0.008) * 12;
            height -= distance * 0.02; // Gentle slope down
            
            // Add valleys and ridges
            height += Math.sin(x * 0.005) * Math.cos(z * 0.006) * 5;
            
            vertices[i + 2] = height;
        }
        
        groundGeometry.computeVertexNormals();
        
        // Create high-quality procedural grass texture with fine detail
        const grassCanvas = document.createElement('canvas');
        grassCanvas.width = 1024; // Higher resolution
        grassCanvas.height = 1024;
        const grassCtx = grassCanvas.getContext('2d');
        
        // Fill with base grass color
        grassCtx.fillStyle = '#4a7c2f';
        grassCtx.fillRect(0, 0, 1024, 1024);
        
        // Add fine grass blade texture with multiple layers
        for (let layer = 0; layer < 3; layer++) {
            for (let i = 0; i < 8000; i++) {
                const x = Math.random() * 1024;
                const y = Math.random() * 1024;
                const brightness = 0.85 + Math.random() * 0.3;
                const length = 2 + Math.random() * 4;
                const width = 0.3 + Math.random() * 0.5;
                
                // Random grass blade color
                const r = Math.floor(74 * brightness);
                const g = Math.floor(124 * brightness);
                const b = Math.floor(47 * brightness);
                
                grassCtx.strokeStyle = `rgba(${r},${g},${b},${0.6 + Math.random() * 0.4})`;
                grassCtx.lineWidth = width;
                grassCtx.beginPath();
                grassCtx.moveTo(x, y);
                grassCtx.lineTo(x + (Math.random() - 0.5) * 2, y - length);
                grassCtx.stroke();
            }
        }
        
        // Add subtle dirt patches
        for (let i = 0; i < 100; i++) {
            const x = Math.random() * 1024;
            const y = Math.random() * 1024;
            const radius = 10 + Math.random() * 30;
            const gradient = grassCtx.createRadialGradient(x, y, 0, x, y, radius);
            gradient.addColorStop(0, 'rgba(90, 70, 40, 0.2)');
            gradient.addColorStop(1, 'rgba(90, 70, 40, 0)');
            grassCtx.fillStyle = gradient;
            grassCtx.fillRect(x - radius, y - radius, radius * 2, radius * 2);
        }
        
        const grassTexture = new THREE.CanvasTexture(grassCanvas);
        grassTexture.wrapS = grassTexture.wrapT = THREE.RepeatWrapping;
        grassTexture.repeat.set(80, 80); // More repetition for finer detail
        grassTexture.anisotropy = renderer.capabilities.getMaxAnisotropy(); // Max quality filtering
        
        const groundMaterial = new THREE.MeshStandardMaterial({
            map: grassTexture,
            roughness: 0.95,
            metalness: 0.0
        });
        ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2; // Rotate to be horizontal
        ground.position.y = 0; // At ground level
        ground.receiveShadow = true;
        scene.add(ground);
        
        // Function to calculate ground height at any position using same formula as terrain
        function getGroundHeightAt(x, z) {
            const distance = Math.sqrt(x * x + z * z);
            let height = Math.sin(x * 0.01) * 8 + Math.cos(z * 0.012) * 6;
            height += Math.sin(x * 0.03 + z * 0.02) * 3;
            height += Math.sin(distance * 0.008) * 12;
            height -= distance * 0.02;
            height += Math.sin(x * 0.005) * Math.cos(z * 0.006) * 5;
            return height;
        }
        
        // Calculate ground height at main turbine position (0, 0)
        const groundHeightAtTurbine = getGroundHeightAt(0, 0);
        
        // Tower - position base at ground height
        const towerGeometry = new THREE.CylinderGeometry(0.8, 1.2, turbineParams.towerHeight, 16);
        const towerMaterial = new THREE.MeshPhongMaterial({ color: 0xcccccc });
        const tower = new THREE.Mesh(towerGeometry, towerMaterial);
        tower.position.y = turbineParams.towerHeight / 2 + groundHeightAtTurbine;
        tower.castShadow = true;
        scene.add(tower);
        
        // Add infinite sky sphere
        const skyGeo = new THREE.SphereGeometry(10000, 64, 64);
        const skyMat = new THREE.ShaderMaterial({
            uniforms: {
                topColor: { value: new THREE.Color(0x0077ff) },
                horizonColor: { value: new THREE.Color(0x87ceeb) },
                sunColor: { value: new THREE.Color(0xffffff) }
            },
            vertexShader: `
                varying vec3 vWorldPosition;
                void main() {
                    vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                    vWorldPosition = worldPosition.xyz;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform vec3 topColor;
                uniform vec3 horizonColor;
                uniform vec3 sunColor;
                varying vec3 vWorldPosition;
                void main() {
                    vec3 direction = normalize(vWorldPosition);
                    float elevation = direction.y;
                    
                    vec3 color;
                    if (elevation > 0.0) {
                        float t = pow(elevation, 0.4);
                        color = mix(horizonColor, topColor, t);
                    } else {
                        float t = pow(abs(elevation), 0.6);
                        color = mix(horizonColor, sunColor, t * 0.3);
                    }
                    
                    gl_FragColor = vec4(color, 1.0);
                }
            `,
            side: THREE.BackSide,
            depthWrite: false,
            depthTest: false
        });
        skyboxMesh = new THREE.Mesh(skyGeo, skyMat);
        skyboxMesh.renderOrder = -1000;
        scene.add(skyboxMesh);
        
        // Add animated cloud layer
        const cloudGeometry = new THREE.PlaneGeometry(1500, 1500, 10, 10);
        const cloudCanvas = document.createElement('canvas');
        cloudCanvas.width = 512;
        cloudCanvas.height = 512;
        const cloudCtx = cloudCanvas.getContext('2d');
        cloudCtx.fillStyle = 'rgba(255, 255, 255, 0)';
        cloudCtx.fillRect(0, 0, 512, 512);
        for (let i = 0; i < 30; i++) {
            const cx = Math.random() * 512;
            const cy = Math.random() * 512;
            const radius = 30 + Math.random() * 70;
            const gradient = cloudCtx.createRadialGradient(cx, cy, 0, cx, cy, radius);
            gradient.addColorStop(0, `rgba(255, 255, 255, ${0.3 + Math.random() * 0.4})`);
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            cloudCtx.fillStyle = gradient;
            cloudCtx.fillRect(0, 0, 512, 512);
        }
        const cloudTexture = new THREE.CanvasTexture(cloudCanvas);
        cloudTexture.wrapS = cloudTexture.wrapT = THREE.RepeatWrapping;
        cloudTexture.repeat.set(3, 3);
        const cloudMaterial = new THREE.MeshBasicMaterial({
            map: cloudTexture,
            transparent: true,
            opacity: 0.5,
            side: THREE.DoubleSide,
            depthWrite: false
        });
        cloudPlane = new THREE.Mesh(cloudGeometry, cloudMaterial);
        cloudPlane.rotation.x = -Math.PI / 2;
        cloudPlane.position.y = 200;
        scene.add(cloudPlane);
        cloudOffset = 0;
        
        // Nacelle (rotates for yaw)
        const nacelleGroup = new THREE.Group();
        nacelleGroup.position.set(0, turbineParams.towerHeight + groundHeightAtTurbine, 0);
        scene.add(nacelleGroup);
        
        const nacelleGeometry = new THREE.BoxGeometry(4, 2, 2);
        const nacelleMaterial = new THREE.MeshPhongMaterial({ color: 0xeeeeee });
        const nacelle = new THREE.Mesh(nacelleGeometry, nacelleMaterial);
        nacelle.castShadow = true;
        nacelleGroup.add(nacelle);
        nacelleGroup.add(nacelleAxes);
        
        // Rotor group (contains hub and blades, rotates about X-axis)
        const rotorGroup = new THREE.Group();
        rotorGroup.position.x = 2;
        nacelleGroup.add(rotorGroup);
        rotorGroup.add(rotorAxes);
        
        // Hub
        const hubGeometry = new THREE.SphereGeometry(turbineParams.hubRadius, 16, 16);
        const hubMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
        const hub = new THREE.Mesh(hubGeometry, hubMaterial);
        hub.castShadow = true;
        rotorGroup.add(hub);
        
        // Cache initial materials for photo mode toggle
        cacheMaterial(tower);
        cacheMaterial(nacelle);
        cacheMaterial(hub);
        cacheMaterial(ground);
        
        // Blades
        const blades = [];
        const bladeSegments = [];
        let forceArrows = [];
        
        // Helper to iterate all meshes for photo mode
        function forEachMesh(fn){
            fn(tower); fn(nacelle); fn(hub); fn(ground);
            bladeSegments.forEach(fn);
        }
        
        function createBlade() {
            const bladeGroup = new THREE.Group();
            
            // Pitch group for visual blade pitch
            const pitchGroup = new THREE.Group();
            bladeGroup.add(pitchGroup);
            
            const numSegments = 100;
            const segments = [];
            
            for (let i = 0; i < numSegments; i++) {
                const r = turbineParams.hubRadius + (i / numSegments) * (turbineParams.bladeRadius - turbineParams.hubRadius);
                const nextR = turbineParams.hubRadius + ((i + 1) / numSegments) * (turbineParams.bladeRadius - turbineParams.hubRadius);
                const segmentLength = nextR - r;
                
                const chord = 1.5 * (1 - i / numSegments) + 0.3;
                
                const segmentGeometry = new THREE.BoxGeometry(0.2, segmentLength, chord);
                const segmentMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x4444ff,
                    shininess: 30,
                    specular: 0x222222
                });
                const segment = new THREE.Mesh(segmentGeometry, segmentMaterial);
                
                segment.position.y = r + segmentLength / 2;
                segment.castShadow = true;
                
                segment.userData.radius = r + segmentLength / 2;
                segment.userData.chord = chord;
                
                pitchGroup.add(segment);
                segments.push(segment);
                bladeSegments.push(segment);
                cacheMaterial(segment); // Cache for photo mode
            }
            
            bladeGroup.segments = segments;
            bladeGroup.pitchGroup = pitchGroup;
            
            // Rotate blade to extend radially
            bladeGroup.rotation.y = Math.PI / 2;
            
            return bladeGroup;
        }
        
        function updateBladeCount() {
            blades.forEach(blade => rotorGroup.remove(blade));
            blades.length = 0;
            bladeSegments.length = 0;
            
            for (let i = 0; i < turbineParams.numBlades; i++) {
                const blade = createBlade();
                blade.rotation.x = (i * 2 * Math.PI) / turbineParams.numBlades;
                rotorGroup.add(blade);
                blades.push(blade);
            }
            
            // Reset plot data when blade count changes
            initPlotData();
            if (typeof liftChart !== 'undefined') {
                rebuildCharts();
            }
            resetFourierCollection();
        }
        
        // Create wind farm with multiple turbines
        function createWindFarm() {
            // Clear existing additional turbines
            additionalTurbines.forEach(t => {
                // Dispose of geometries and materials
                t.traverse(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(m => m.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                });
                scene.remove(t);
            });
            additionalTurbines = [];
            
            if (!turbineParams.windFarmMode) return;
            
            // Preset positions for additional 4 turbines (main turbine at 0,0)
            const positions = [
                {x: -60, z: -40},
                {x: 60, z: -40},
                {x: -60, z: 40},
                {x: 60, z: 40}
            ];
            
            positions.forEach((pos, i) => {
                // Calculate ground height at this turbine's position
                const groundHeight = getGroundHeightAt(pos.x, pos.z);
                
                const turbineGroup = new THREE.Group();
                turbineGroup.position.set(pos.x, groundHeight, pos.z);
                
                // Speed variation for this turbine
                const speedMultiplier = 1 + (Math.random() - 0.5) * 2 * turbineParams.speedVariation;
                turbineGroup.userData.speedMultiplier = speedMultiplier;
                
                // Clone tower
                const towerGeo = new THREE.CylinderGeometry(0.8, 1.2, turbineParams.towerHeight, 16);
                const towerMat = new THREE.MeshPhongMaterial({ color: 0xcccccc });
                const towerClone = new THREE.Mesh(towerGeo, towerMat);
                towerClone.position.y = turbineParams.towerHeight / 2;
                towerClone.castShadow = true;
                turbineGroup.add(towerClone);
                
                // Clone nacelle group
                const nacelleGrp = new THREE.Group();
                nacelleGrp.position.set(0, turbineParams.towerHeight, 0);
                
                const nacelleGeo = new THREE.BoxGeometry(4, 2, 2);
                const nacelleMat = new THREE.MeshPhongMaterial({ color: 0xeeeeee });
                const nacelleClone = new THREE.Mesh(nacelleGeo, nacelleMat);
                nacelleClone.castShadow = true;
                nacelleGrp.add(nacelleClone);
                turbineGroup.add(nacelleGrp);
                
                // Clone rotor group
                const rotorGrp = new THREE.Group();
                rotorGrp.position.x = 2;
                nacelleGrp.add(rotorGrp);
                
                // Clone hub
                const hubGeo = new THREE.SphereGeometry(turbineParams.hubRadius, 16, 16);
                const hubMat = new THREE.MeshPhongMaterial({ color: 0x888888 });
                const hubClone = new THREE.Mesh(hubGeo, hubMat);
                hubClone.castShadow = true;
                rotorGrp.add(hubClone);
                
                // Clone blades
                for (let j = 0; j < turbineParams.numBlades; j++) {
                    const bladeGroup = new THREE.Group();
                    const pitchGroup = new THREE.Group();
                    bladeGroup.add(pitchGroup);
                    
                    const numSegments = 20; // Simpler blades for performance
                    for (let k = 0; k < numSegments; k++) {
                        const r = turbineParams.hubRadius + (k / numSegments) * (turbineParams.bladeRadius - turbineParams.hubRadius);
                        const nextR = turbineParams.hubRadius + ((k + 1) / numSegments) * (turbineParams.bladeRadius - turbineParams.hubRadius);
                        const segmentLength = nextR - r;
                        const chord = 1.5 * (1 - k / numSegments) + 0.3;
                        
                        const segGeo = new THREE.BoxGeometry(0.2, segmentLength, chord);
                        const segMat = new THREE.MeshPhongMaterial({ color: 0x4444ff });
                        const segment = new THREE.Mesh(segGeo, segMat);
                        segment.position.y = r + segmentLength / 2;
                        segment.castShadow = true;
                        pitchGroup.add(segment);
                    }
                    
                    bladeGroup.rotation.y = Math.PI / 2;
                    bladeGroup.rotation.x = (j * 2 * Math.PI) / turbineParams.numBlades;
                    rotorGrp.add(bladeGroup);
                }
                
                turbineGroup.userData.rotorGroup = rotorGrp;
                turbineGroup.userData.nacelleGroup = nacelleGrp;
                
                scene.add(turbineGroup);
                additionalTurbines.push(turbineGroup);
            });
        }
        
        // Color mapping function (enhanced with more stops)
        function getLoadColor(normalizedLoad) {
            const colors = [
                { pos: 0.0, color: new THREE.Color(0x0000ff) },   // Blue
                { pos: 0.14, color: new THREE.Color(0x0080ff) },  // Light blue
                { pos: 0.28, color: new THREE.Color(0x00ffff) },  // Cyan
                { pos: 0.42, color: new THREE.Color(0x00ff00) },  // Green
                { pos: 0.57, color: new THREE.Color(0xffff00) },  // Yellow
                { pos: 0.71, color: new THREE.Color(0xff8000) },  // Orange
                { pos: 0.85, color: new THREE.Color(0xff0000) },  // Red
                { pos: 1.0, color: new THREE.Color(0x8b0000) }    // Dark red
            ];
            
            for (let i = 0; i < colors.length - 1; i++) {
                if (normalizedLoad >= colors[i].pos && normalizedLoad <= colors[i + 1].pos) {
                    const t = (normalizedLoad - colors[i].pos) / (colors[i + 1].pos - colors[i].pos);
                    return new THREE.Color().lerpColors(colors[i].color, colors[i + 1].color, t);
                }
            }
            return colors[colors.length - 1].color;
        }
        
        // Update blade loads
        function updateBladeLoads() {
            const omega = turbineParams.shaftSpeed * 2 * Math.PI / 60;
            const windSpeed = turbineParams.windSpeed;
            const yawRadians = turbineParams.yawAngle * Math.PI / 180;
            const inflowRadians = turbineParams.inflowAngle * Math.PI / 180;
            
            // Wind speed components due to yaw
            const windSpeedAxial = windSpeed * Math.cos(yawRadians);
            const windSpeedTangential = windSpeed * Math.sin(yawRadians);
            
            let maxLoad = -Infinity;
            let minLoad = Infinity;
            let totalAoA = 0;
            let aoaCount = 0;
            
            blades.forEach((blade, bladeIndex) => {
                // Calculate azimuth from blade's actual rotation in the rotor
                // blade.rotation.x is the blade's offset, rotorGroup.rotation.x is the current rotor angle
                const azimuth = rotorGroup.rotation.x + blade.rotation.x;
                
                // Store azimuth at blade level for consistent data collection
                blade.userData.currentAzimuth = azimuth;
                
                blade.segments.forEach((segment, segIdx) => {
                    const r = segment.userData.radius;
                    const chord = segment.userData.chord;
                    
                    // Blade twist distribution (typical for wind turbine)
                    // Higher twist at root (low speed), lower at tip (high speed)
                    // Range: ~14¬∞ at root to ~0¬∞ at tip
                    const r_norm = (r - turbineParams.hubRadius) / (turbineParams.bladeRadius - turbineParams.hubRadius);
                    const twist = 14 * (1 - r_norm); // Linear twist from 14¬∞ at root to 0¬∞ at tip
                    
                    // Velocities in rotor disc coordinates
                    // alpha = angle of attack (inflow), beta = sideslip (yaw)
                    // Disc velocity components:
                    // x = V sin(beta) - horizontal in-plane
                    // y = V sin(alpha) cos(beta) - vertical in-plane  
                    // z = V cos(alpha) cos(beta) - axial (thrust direction)
                    
                    const V = turbineParams.windSpeed;
                    const alpha = inflowRadians;
                    const beta = yawRadians;
                    
                    const V_x = V * Math.sin(beta);
                    const V_y = V * Math.sin(alpha) * Math.cos(beta);
                    const V_z = V * Math.cos(alpha) * Math.cos(beta);
                    
                    // In-plane velocity component at blade azimuth (perpendicular to radius)
                    // This adds to tangential velocity
                    const V_inplane_tangential = V_x * Math.cos(azimuth) - V_y * Math.sin(azimuth);
                    
                    // Tangential velocity (rotation + in-plane wind)
                    const Vt = omega * r + V_inplane_tangential;
                    
                    // Normal velocity (axial wind + induction)
                    const Vn = -V_z * (1 - 0.3); // With induction factor
                    
                    // Flow angle and angle of attack
                    const phi = Math.atan2(Vn, Vt);
                    const aoa = -(phi * 180 / Math.PI - twist + turbineParams.bladePitch);
                    
                    totalAoA += aoa;
                    aoaCount++;
                    
                    // Dynamic pressure
                    const V_total = Math.sqrt(Vt * Vt + Vn * Vn);
                    const q = 0.5 * 1.225 * V_total * V_total * chord * (turbineParams.bladeRadius / 100);
                    
                    // Simple aerodynamic model
                    // Lift: 2œÄ lift slope (thin airfoil theory)
                    // Drag: constant 5% of lift magnitude
                    const Cl = 2 * Math.PI * Math.sin(aoa * Math.PI / 180);
                    const L = q * Cl;
                    const D = 0.05 * Math.abs(L);
                    
                    // Thrust (axial force)
                    const thrust = L * Math.cos(phi) + D * Math.sin(phi);
                    
                    // Store values (including azimuth for consistent plotting)
                    const load = Math.abs(thrust);
                    segment.userData.load = load;
                    segment.userData.aoa = aoa;
                    segment.userData.azimuth = azimuth;
                    segment.userData.thrust = thrust;
                    segment.userData.L = L;  // Store lift for resultant vector
                    segment.userData.D = D;  // Store drag for resultant vector
                    segment.userData.phi = phi;  // Store flow angle for resultant vector
                    
                    if (load > maxLoad) maxLoad = load;
                    if (load < minLoad) minLoad = load;
                });
            });
            
            // Update force vectors visualization - show as load distribution
            if (turbineParams.showVectors) {
                // Properly dispose of old geometries and materials to prevent memory leaks
                forceArrows.forEach(arrow => {
                    scene.remove(arrow);
                    if (arrow.geometry) arrow.geometry.dispose();
                    if (arrow.material) arrow.material.dispose();
                });
                forceArrows = [];
                
                blades.forEach((blade, bladeIndex) => {
                    // Skip blades if single blade mode
                    if (turbineParams.vectorMode === 'single' && bladeIndex !== 0) return;
                    
                    const points = [];
                    const basePoints = [];
                    
                    // Collect points for load distribution curve
                    blade.segments.forEach((segment, segIdx) => {
                        const L = segment.userData.L || 0;
                        const D = segment.userData.D || 0;
                        const phi = segment.userData.phi || 0;
                        
                        // Get segment world position (base of vector)
                        const worldPos = new THREE.Vector3();
                        segment.getWorldPosition(worldPos);
                        basePoints.push(worldPos.clone());
                        
                        // Resultant force in blade section coordinates:
                        // Lift is perpendicular to relative velocity (rotated by phi from tangent)
                        // Drag is parallel to relative velocity
                        // 
                        // In blade section frame (tangent/normal to blade):
                        // - Tangent direction is along blade motion (perpendicular to radius)
                        // - Normal direction is toward leading edge
                        //
                        // Force components in section frame:
                        // F_tangent = L * sin(phi) - D * cos(phi)  (tangential force, creates torque)
                        // F_normal = L * cos(phi) + D * sin(phi)   (normal force, creates thrust)
                        
                        const F_tangent = L * Math.sin(phi) - D * Math.cos(phi);
                        const F_normal = L * Math.cos(phi) + D * Math.sin(phi);
                        
                        // Get the tangent direction (blade motion direction, perpendicular to radius)
                        // In the blade's local frame, tangent is along +Z (spanwise cross radial)
                        const tangentDir = new THREE.Vector3(0, 0, 1);
                        tangentDir.applyQuaternion(segment.getWorldQuaternion(new THREE.Quaternion()));
                        
                        // Normal direction is toward leading edge (along +X in blade frame)
                        const normalDir = new THREE.Vector3(1, 0, 0);
                        normalDir.applyQuaternion(segment.getWorldQuaternion(new THREE.Quaternion()));
                        
                        // Resultant force vector
                        const forceVec = normalDir.multiplyScalar(F_normal).add(
                            tangentDir.multiplyScalar(F_tangent)
                        );
                        
                        // Scale vector by scale factor
                        const vectorLength = turbineParams.vectorScale;
                        const tipPos = worldPos.clone().add(forceVec.multiplyScalar(vectorLength));
                        points.push(tipPos);
                    });
                    
                    // Create lines from base to tip for each segment
                    for (let i = 0; i < points.length; i++) {
                        const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                            basePoints[i],
                            points[i]
                        ]);
                        const lineMaterial = new THREE.LineBasicMaterial({ 
                            color: 0xff0000,
                            linewidth: 1,
                            transparent: true,
                            opacity: 0.6
                        });
                        const line = new THREE.Line(lineGeometry, lineMaterial);
                        scene.add(line);
                        forceArrows.push(line);
                    }
                    
                    // Create curve connecting all tips (load distribution envelope)
                    if (points.length > 1) {
                        const curveGeometry = new THREE.BufferGeometry().setFromPoints(points);
                        const curveMaterial = new THREE.LineBasicMaterial({ 
                            color: 0xff0000,
                            linewidth: 2
                        });
                        const curve = new THREE.Line(curveGeometry, curveMaterial);
                        scene.add(curve);
                        forceArrows.push(curve);
                    }
                });
            } else {
                // Hide vectors if disabled - properly dispose to prevent memory leaks
                forceArrows.forEach(arrow => {
                    scene.remove(arrow);
                    if (arrow.geometry) arrow.geometry.dispose();
                    if (arrow.material) arrow.material.dispose();
                });
                forceArrows = [];
            }
            
            // Apply mean removal to heatmap loads if enabled
            if (turbineParams.removeMean) {
                // Calculate mean thrust across all blade segments
                let totalThrust = 0;
                let segmentCount = 0;
                bladeSegments.forEach(segment => {
                    if (segment.userData.thrust !== undefined) {
                        totalThrust += segment.userData.thrust;
                        segmentCount++;
                    }
                });
                const meanThrust = segmentCount > 0 ? totalThrust / segmentCount : 0;
                
                // Recalculate loads with mean removed
                maxLoad = -Infinity;
                minLoad = Infinity;
                bladeSegments.forEach(segment => {
                    if (segment.userData.thrust !== undefined) {
                        const demeanedThrust = segment.userData.thrust - meanThrust;
                        const load = Math.abs(demeanedThrust);
                        segment.userData.load = load;
                        if (load > maxLoad) maxLoad = load;
                        if (load < minLoad) minLoad = load;
                    }
                });
            }
            
            // Autoscale and color segments
            const loadRange = maxLoad - minLoad;
            bladeSegments.forEach(segment => {
                if (turbineParams.showHeatmap) {
                    const normalizedLoad = loadRange > 0 ? (segment.userData.load - minLoad) / loadRange : 0;
                    const color = getLoadColor(normalizedLoad);
                    if (isPhotoMode){
                        // tint base color slightly + glow with emissive
                        segment.material.color.lerp(color, 0.35);
                        if (segment.material.emissive) {
                            segment.material.emissive.lerp(color, 0.6);
                        }
                    } else {
                        segment.material.color = color.clone ? color.clone() : color;
                    }
                } else {
                    // Reset to neutral color when heatmap is off
                    const neutralColor = new THREE.Color(0xcccccc);
                    if (isPhotoMode && segment.material.emissive) {
                        segment.material.color.copy(neutralColor);
                        segment.material.emissive.set(0x000000);
                    } else {
                        segment.material.color.copy(neutralColor);
                    }
                }
            });
            
            // Update stats (dimensionless)
            document.getElementById('max-load').textContent = maxLoad.toFixed(2);
            document.getElementById('avg-aoa').textContent = (totalAoA / aoaCount).toFixed(1);
            const tipSpeed = (turbineParams.shaftSpeed * 2 * Math.PI / 60) * turbineParams.bladeRadius;
            document.getElementById('tip-speed').textContent = tipSpeed.toFixed(1);
            
            // Update plot data
            if (omega > 0) {
                timeCounter++;
                
                // Calculate update interval based on angular resolution
                // angularResolution is in degrees, we need to convert to radians and calculate frames
                const degreesPerFrame = (turbineParams.shaftSpeed * 360) / (60 * 60); // degrees per frame at 60fps
                const framesPerSample = turbineParams.angularResolution / degreesPerFrame;
                const updateInterval = Math.max(1, Math.round(framesPerSample));
                
                // Only update plot data when not paused
                if (timeCounter % updateInterval === 0 && !turbineParams.paused) {
                    updatePlotData(omega);
                }
            }
        }
        
        // Photo Mode Enable/Disable Functions
        function enablePhotoMode(){
            if (isPhotoMode) return;
            isPhotoMode = true;

            // Renderer: physically-correct pipeline
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2; // Brighter for outdoor scene
            renderer.physicallyCorrectLights = true;

            // Enhanced lighting for photorealism
            // 1. Warm sunlight (5500K color temperature)
            directionalLight.color.setHex(0xffffee);
            directionalLight.intensity = 3.5;
            directionalLight.position.set(100, 80, 100); // More dramatic angle
            
            // 2. Enhanced shadow system (4096x4096 for crisp shadows)
            directionalLight.shadow.mapSize.set(4096, 4096);
            directionalLight.shadow.camera.left = -150;
            directionalLight.shadow.camera.right = 150;
            directionalLight.shadow.camera.top = 150;
            directionalLight.shadow.camera.bottom = -150;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 500;
            directionalLight.shadow.bias = -0.0001; // Prevent shadow acne
            directionalLight.shadow.radius = 2; // Softer shadow edges
            
            // 3. Hemisphere light for natural sky/ground bounce
            const hemiLight = new THREE.HemisphereLight(
                0x87ceeb,  // Sky color (light blue)
                0x4a7c2f,  // Ground color (grass green)
                0.6        // Intensity
            );
            hemiLight.position.set(0, 50, 0);
            scene.add(hemiLight);
            hemiLight.userData.isPhotoModeLight = true;
            
            // 4. Subtle rim light from opposite side
            const rimLight = new THREE.DirectionalLight(0xccddff, 0.3);
            rimLight.position.set(-80, 40, -80);
            scene.add(rimLight);
            rimLight.userData.isPhotoModeLight = true;
            
            // 5. Atmospheric fog for depth
            scene.fog = new THREE.FogExp2(0xe0f0ff, 0.0015); // Exponential fog, horizon color

            // HDRI env for reflections and background
            if (!pmremGen) pmremGen = new THREE.PMREMGenerator(renderer);
            new THREE.RGBELoader().load(PhotoConfig.HDRI_URL, (hdr)=>{
                const tex = pmremGen.fromEquirectangular(hdr).texture;
                envMap = tex;
                scene.environment = envMap; // For reflections on materials ONLY
                // Don't set scene.background - use gradient sky instead
                hdr.dispose();
            });
            
            // Create infinite-looking sky sphere that completely surrounds the scene
            const skyGeo = new THREE.SphereGeometry(10000, 64, 64); // HUGE sphere for true infinity feel
            const skyMat = new THREE.ShaderMaterial({
                uniforms: {
                    topColor: { value: new THREE.Color(0x0077ff) },      // Bright sky blue
                    horizonColor: { value: new THREE.Color(0x87ceeb) },  // Sky blue horizon
                    sunColor: { value: new THREE.Color(0xffffff) }       // White near horizon
                },
                vertexShader: `
                    varying vec3 vWorldPosition;
                    void main() {
                        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                        vWorldPosition = worldPosition.xyz;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 topColor;
                    uniform vec3 horizonColor;
                    uniform vec3 sunColor;
                    varying vec3 vWorldPosition;
                    void main() {
                        // Normalized direction from center
                        vec3 direction = normalize(vWorldPosition);
                        float elevation = direction.y; // -1 (down) to +1 (up)
                        
                        vec3 color;
                        if (elevation > 0.0) {
                            // Sky above horizon: smooth blend from horizon to top
                            // Use exponential for more realistic atmosphere
                            float t = pow(elevation, 0.4);
                            color = mix(horizonColor, topColor, t);
                        } else {
                            // Below horizon: blend to lighter color (atmospheric glow)
                            float t = pow(abs(elevation), 0.6);
                            color = mix(horizonColor, sunColor, t * 0.3);
                        }
                        
                        gl_FragColor = vec4(color, 1.0);
                    }
                `,
                side: THREE.BackSide,
                depthWrite: false,
                depthTest: false
            });
            skyboxMesh = new THREE.Mesh(skyGeo, skyMat);
            skyboxMesh.renderOrder = -1000;
            scene.add(skyboxMesh);
            
            // Create animated cloud layer with procedural texture
            const cloudGeometry = new THREE.PlaneGeometry(1500, 1500, 10, 10);
            
            // Create procedural cloud texture using canvas
            const cloudCanvas = document.createElement('canvas');
            cloudCanvas.width = 512;
            cloudCanvas.height = 512;
            const ctx = cloudCanvas.getContext('2d');
            
            // Generate cloud-like pattern
            ctx.fillStyle = 'rgba(255, 255, 255, 0)';
            ctx.fillRect(0, 0, 512, 512);
            
            // Draw multiple layers of soft clouds
            for (let i = 0; i < 30; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const radius = 30 + Math.random() * 70;
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                gradient.addColorStop(0, `rgba(255, 255, 255, ${0.3 + Math.random() * 0.4})`);
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 512, 512);
            }
            
            const cloudTexture = new THREE.CanvasTexture(cloudCanvas);
            cloudTexture.wrapS = cloudTexture.wrapT = THREE.RepeatWrapping;
            cloudTexture.repeat.set(3, 3);
            
            const cloudMaterial = new THREE.MeshBasicMaterial({
                map: cloudTexture,
                transparent: true,
                opacity: 0.5,
                side: THREE.DoubleSide,
                depthWrite: false
            });
            
            cloudPlane = new THREE.Mesh(cloudGeometry, cloudMaterial);
            cloudPlane.rotation.x = -Math.PI / 2; // Face up
            cloudPlane.position.y = 200; // High in the sky
            cloudPlane.userData.isCloudLayer = true;
            scene.add(cloudPlane);
            
            // SKIP gradient skybox - using HDRI as background instead
            // The HDRI background is set above via scene.background = envMap
            
            // Add sun disk for realism
            const sunGeo = new THREE.SphereGeometry(15, 16, 16);
            const sunMat = new THREE.MeshBasicMaterial({
                color: 0xffffdd,
                fog: false
            });
            const sunMesh = new THREE.Mesh(sunGeo, sunMat);
            sunMesh.position.set(450, 350, 450); // Position relative to sun direction
            sunMesh.userData.isSun = true;
            scene.add(sunMesh);
            
            // SKIP duplicate terrain - now using shared terrain in both modes
            // The main scene terrain already has the same undulation
            
            // Don't hide ground - we're using the same terrain in both modes
            // ground.visible = true; // Keep it visible

            // Swap to enhanced PBR materials
            forEachMesh((m)=>{
                const old = OriginalMats.get(m);
                if (!old.userData?.__pbrClone){
                    let pbr;
                    if (m === tower) {
                        // Tower: Painted metal (more metallic, less rough)
                        pbr = new THREE.MeshPhysicalMaterial({
                            color: 0xe5e5e5,
                            metalness: 0.85,
                            roughness: 0.2,
                            clearcoat: 0.3,
                            clearcoatRoughness: 0.25,
                            envMapIntensity: 1.2
                        });
                    } else if (m === nacelle) {
                        // Nacelle: Painted metal housing
                        pbr = new THREE.MeshPhysicalMaterial({
                            color: 0xf0f0f0,
                            metalness: 0.8,
                            roughness: 0.25,
                            clearcoat: 0.4,
                            clearcoatRoughness: 0.2,
                            envMapIntensity: 1.2
                        });
                    } else if (m === hub) {
                        // Hub: Cast iron/steel (darker, more metal)
                        pbr = new THREE.MeshPhysicalMaterial({
                            color: 0x666666,
                            metalness: 0.8,
                            roughness: 0.3,
                            clearcoat: 0.2,
                            clearcoatRoughness: 0.4,
                            envMapIntensity: 1.0
                        });
                    } else if (m === ground) {
                        // Ground (not used in photo mode, but handle anyway)
                        pbr = new THREE.MeshStandardMaterial({
                            color: 0x4a7c59,
                            roughness: 0.9,
                            metalness: 0.0
                        });
                    } else {
                        // Blades: Composite material with clearcoat
                        pbr = new THREE.MeshPhysicalMaterial({
                            color: 0xdddddd,
                            metalness: 0.1,
                            roughness: 0.4,
                            clearcoat: 0.6, // Glossy composite finish
                            clearcoatRoughness: 0.25,
                            envMapIntensity: 0.8
                        });
                    }
                    old.userData = old.userData || {};
                    old.userData.__pbrClone = pbr;
                    m.material = pbr;
                } else {
                    m.material = old.userData.__pbrClone;
                }
            });

            // Keep your load heatmap‚Äîuse emissive so PBR still reads
            bladeSegments.forEach(seg=>{
                seg.material.emissive = new THREE.Color(0x000000);
                seg.material.emissiveIntensity = 0.6;
            });

            // Enhanced postprocessing stack
            composer = new THREE.EffectComposer(renderer);
            renderPass = new THREE.RenderPass(scene, camera);
            composer.addPass(renderPass);

            // Subtle bloom for highlights (reduced for realism)
            bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                0.25,  // Reduced strength (was 0.35)
                0.8,   // Radius
                0.9    // Higher threshold (was 0.85) - less bloom on normal objects
            );
            composer.addPass(bloomPass);

            // Only add bokeh if enabled (reduces background blur)
            if (PhotoConfig.useBokeh) {
                bokehPass = new THREE.BokehPass(scene, camera, {
                    focus: PhotoConfig.bokehFocusFar,
                    aperture: PhotoConfig.bokehAperture,
                    maxblur: PhotoConfig.bokehMaxBlur
                });
                composer.addPass(bokehPass);
            }

            fxaaPass = new THREE.ShaderPass(THREE.FXAAShader);
            fxaaPass.material.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight);
            composer.addPass(fxaaPass);

            // Optional: lighten fog or remove for hero look
            scene.fog = null;
        }

        function disablePhotoMode(){
            if (!isPhotoMode) return;
            isPhotoMode = false;

            // Restore renderer defaults
            renderer.physicallyCorrectLights = false;
            renderer.toneMapping = THREE.NoToneMapping;
            renderer.toneMappingExposure = 1.0;

            // Restore simple light intensity and color
            directionalLight.intensity = OriginalLook.dirLightIntensity;
            directionalLight.color.setHex(0xffffff);
            directionalLight.position.set(50, 50, 50);

            // Remove photo mode lights (hemisphere and rim light)
            scene.children.forEach((child, index) => {
                if (child.userData && child.userData.isPhotoModeLight) {
                    scene.remove(child);
                }
            });

            // Restore background/fog and remove skybox + sun
            scene.environment = null;
            scene.background = OriginalLook.background || new THREE.Color(0x87ceeb);
            scene.fog = null; // No fog in default mode
            
            // Remove skybox
            if (skyboxMesh) {
                scene.remove(skyboxMesh);
                skyboxMesh.geometry.dispose();
                skyboxMesh.material.dispose();
                skyboxMesh = null;
            }
            
            // Remove cloud layer
            if (cloudPlane) {
                scene.remove(cloudPlane);
                cloudPlane.geometry.dispose();
                cloudPlane.material.map.dispose();
                cloudPlane.material.dispose();
                cloudPlane = null;
                cloudOffset = 0;
            }
            
            // Remove sun disk
            scene.children.forEach(child => {
                if (child.userData && child.userData.isSun) {
                    scene.remove(child);
                    child.geometry.dispose();
                    child.material.dispose();
                }
            });
            
            // Remove hillside and restore original ground
            scene.children.forEach(child => {
                if (child.userData && child.userData.isHillside) {
                    scene.remove(child);
                    child.geometry.dispose();
                    child.material.dispose();
                }
            });
            
            // Ground is always visible now (same terrain in both modes)
            // ground.visible = true; // Already visible

            // Restore original materials
            forEachMesh((m)=>{
                const orig = OriginalMats.get(m);
                if (orig) m.material = orig;
            });

            // Kill post stack
            composer = null; renderPass = null; bloomPass = null; bokehPass = null; fxaaPass = null;
        }
        
        // Update plot data
        function updatePlotData(omega) {
            const targetRadius = turbineParams.radialStation * turbineParams.bladeRadius;
            const bladeLifts = [];
            const bladeMomentsY = [];
            const bladeMomentsZ = [];
            let totalLift = 0;
            let totalMomentY = 0;  // Vertical bending moment (nodding)
            let totalMomentZ = 0;  // Horizontal bending moment (yawing)
            
            blades.forEach((blade, bladeIndex) => {
                // Use the azimuth that was stored when thrust was calculated
                const azimuth = blade.userData.currentAzimuth || 0;
                
                // Find segment closest to target radius
                let closestSegment = null;
                let minDist = Infinity;
                blade.segments.forEach(segment => {
                    const dist = Math.abs(segment.userData.radius - targetRadius);
                    if (dist < minDist) {
                        minDist = dist;
                        closestSegment = segment;
                    }
                });
                
                if (closestSegment) {
                    const thrust = closestSegment.userData.thrust || 0;
                    bladeLifts.push(thrust);
                    
                    // Bending moment in non-rotating frame
                    // Each blade creates a moment about the tower base
                    const momentArm = closestSegment.userData.radius;
                    
                    // Decompose into fixed frame components using the stored azimuth
                    const momentY = thrust * momentArm * Math.sin(azimuth);   // Yawing (about vertical Y-axis)
                    const momentZ = -thrust * momentArm * Math.cos(azimuth);  // Nodding (about horizontal Z-axis)
                    
                    bladeMomentsY.push(momentY);
                    bladeMomentsZ.push(momentZ);
                    
                    totalLift += thrust;
                    totalMomentY += momentY;
                    totalMomentZ += momentZ;
                } else {
                    bladeLifts.push(0);
                    bladeMomentsY.push(0);
                    bladeMomentsZ.push(0);
                }
            });
            
            // Store data with continuous time for scrolling x-axis
            // Increment time value based on rotation speed
            const deltaTime = omega * (2 * Math.PI) / (60 * 60); // radians per frame
            plotData.timeValue += deltaTime;
            
            // Check for TDC crossing (when blade 1 azimuth crosses 0¬∞/360¬∞)
            const blade1Azimuth = blades[0].userData.currentAzimuth || 0;
            const blade1AzimuthDeg = ((blade1Azimuth * 180 / Math.PI) % 360 + 360) % 360;
            
            // Detect TDC crossing by checking if azimuth wrapped around
            if (blades[0].userData.previousAzimuth !== undefined) {
                const prevAzimuth = blades[0].userData.previousAzimuth;
                const prevAzimuthDeg = ((prevAzimuth * 180 / Math.PI) % 360 + 360) % 360;
                // Check if we crossed from 350-360 to 0-10 degrees
                if (prevAzimuthDeg > 350 && blade1AzimuthDeg < 10) {
                    plotData.tdcMarkers.push(plotData.timeValue);
                }
            }
            blades[0].userData.previousAzimuth = blade1Azimuth;
            
            plotData.time.push(plotData.timeValue.toFixed(3));
            
            // Store raw data (always store the raw values)
            for (let i = 0; i < turbineParams.numBlades; i++) {
                if (plotData.bladeLift[i]) {
                    plotData.bladeLift[i].push(bladeLifts[i] || 0);
                    plotData.bladeMomentY[i].push(bladeMomentsY[i] || 0);
                    plotData.bladeMomentZ[i].push(bladeMomentsZ[i] || 0);
                }
            }
            plotData.totalLift.push(totalLift);
            plotData.totalMomentY.push(totalMomentY);
            plotData.totalMomentZ.push(totalMomentZ);
            
            // Fourier data collection - collect for exactly one revolution
            if (!turbineParams.paused && omega > 0) {
                // Start collection if not already collecting
                if (!fourierData.collecting && !fourierData.complete) {
                    startFourierCollection();
                }
                
                // Check if we've completed one revolution
                if (fourierData.collecting) {
                    const currentAzimuth = rotorGroup.rotation.x;
                    const angleTraveled = currentAzimuth - fourierData.startAzimuth;
                    const angleInDegrees = (angleTraveled * 180 / Math.PI) % 360;
                    
                    // Check if enough angular distance has passed since last collection
                    const shouldCollect = (angleInDegrees - fourierData.lastCollectionTime) >= fourierData.samplingInterval;
                    
                    // Store data point at specified sampling interval
                    if (shouldCollect && bladeLifts[0] !== undefined) {
                        fourierData.bladeLift.push(bladeLifts[0]);
                        fourierData.bladeMomentY.push(bladeMomentsY[0]);
                        fourierData.bladeMomentZ.push(bladeMomentsZ[0]);
                        fourierData.totalLift.push(totalLift);
                        fourierData.totalMomentY.push(totalMomentY);
                        fourierData.totalMomentZ.push(totalMomentZ);
                        fourierData.lastCollectionTime = angleInDegrees;
                    }
                    
                    // Check if we've completed one full revolution (2œÄ radians)
                    if (angleTraveled >= 2 * Math.PI) {
                        fourierData.collecting = false;
                        fourierData.complete = true;
                        // After first fast collection, switch to normal mode for subsequent collections
                        if (fourierData.fastMode) {
                            fourierData.fastMode = false;
                            // Clear all trace data after fast collection completes
                            initPlotData();
                            updateCharts();
                        }
                    }
                }
            }
            
            // Limit data to exactly 2 revolutions (720¬∞)
            // Calculate max points based on angular resolution
            const degreesPerRevolution = 360;
            const maxRevolutions = 2;
            const maxDataPoints = Math.ceil((degreesPerRevolution * maxRevolutions) / turbineParams.angularResolution);
            
            // Once we have max points, start removing from the left (scrolling)
            if (plotData.time.length > maxDataPoints) {
                plotData.time.shift();
                plotData.bladeLift.forEach(arr => arr.shift());
                plotData.bladeMomentY.forEach(arr => arr.shift());
                plotData.bladeMomentZ.forEach(arr => arr.shift());
                plotData.totalLift.shift();
                plotData.totalMomentY.shift();
                plotData.totalMomentZ.shift();
                
                // Keep only the 2 most recent TDC markers
                if (plotData.tdcMarkers.length > 2) {
                    plotData.tdcMarkers.shift();
                }
            }
            
            // Safety check: hard limit to prevent memory issues
            const absoluteMaxPoints = 5000; // Emergency brake
            if (plotData.time.length > absoluteMaxPoints) {
                console.warn('Data array exceeded safety limit, clearing oldest data');
                const excessPoints = plotData.time.length - maxDataPoints;
                for (let i = 0; i < excessPoints; i++) {
                    plotData.time.shift();
                    plotData.bladeLift.forEach(arr => arr.shift());
                    plotData.bladeMomentY.forEach(arr => arr.shift());
                    plotData.bladeMomentZ.forEach(arr => arr.shift());
                    plotData.totalLift.shift();
                    plotData.totalMomentY.shift();
                    plotData.totalMomentZ.shift();
                }
            }
            
            // Update charts
            updateCharts();
            
            // Update spanwise analysis displays (less frequently)
            if (frameCount % 5 === 0) { // Update every 5 frames
                updateSpanwiseChart();
                updateSectionDiagram();
            }
        }
        
        // Update chart displays
        function updateCharts() {
            if (plotData.bladeLift.length !== turbineParams.numBlades) {
                // Data arrays don't match blade count, skip update
                return;
            }
            
            // Prepare data for display (with optional mean removal)
            let displayBladeLift = plotData.bladeLift;
            let displayBladeMomentY = plotData.bladeMomentY;
            let displayBladeMomentZ = plotData.bladeMomentZ;
            let displayTotalLift = plotData.totalLift;
            let displayTotalMomentY = plotData.totalMomentY;
            let displayTotalMomentZ = plotData.totalMomentZ;
            
            if (turbineParams.removeMean) {
                // Calculate and subtract mean from each dataset
                displayBladeLift = plotData.bladeLift.map(bladeData => {
                    if (bladeData && bladeData.length > 0) {
                        const mean = bladeData.reduce((a, b) => a + b, 0) / bladeData.length;
                        return bladeData.map(v => v - mean);
                    }
                    return bladeData;
                });
                
                displayBladeMomentY = plotData.bladeMomentY.map(bladeData => {
                    if (bladeData && bladeData.length > 0) {
                        const mean = bladeData.reduce((a, b) => a + b, 0) / bladeData.length;
                        return bladeData.map(v => v - mean);
                    }
                    return bladeData;
                });
                
                displayBladeMomentZ = plotData.bladeMomentZ.map(bladeData => {
                    if (bladeData && bladeData.length > 0) {
                        const mean = bladeData.reduce((a, b) => a + b, 0) / bladeData.length;
                        return bladeData.map(v => v - mean);
                    }
                    return bladeData;
                });
                
                // Remove mean from totals
                if (plotData.totalLift.length > 0) {
                    const meanLift = plotData.totalLift.reduce((a, b) => a + b, 0) / plotData.totalLift.length;
                    displayTotalLift = plotData.totalLift.map(v => v - meanLift);
                }
                
                if (plotData.totalMomentY.length > 0) {
                    const meanMomentY = plotData.totalMomentY.reduce((a, b) => a + b, 0) / plotData.totalMomentY.length;
                    displayTotalMomentY = plotData.totalMomentY.map(v => v - meanMomentY);
                }
                
                if (plotData.totalMomentZ.length > 0) {
                    const meanMomentZ = plotData.totalMomentZ.reduce((a, b) => a + b, 0) / plotData.totalMomentZ.length;
                    displayTotalMomentZ = plotData.totalMomentZ.map(v => v - meanMomentZ);
                }
            }
            
            // Calculate dynamic x-axis bounds based on current data
            let xMin = 0;
            let xMax = 4 * Math.PI; // Default to 4œÄ (720¬∞)
            
            if (plotData.time.length > 0) {
                const firstTime = parseFloat(plotData.time[0]);
                const lastTime = parseFloat(plotData.time[plotData.time.length - 1]);
                
                // If we haven't filled the buffer yet, show from 0 to current max (clipped to 4œÄ)
                const maxDataPoints = Math.ceil((360 * 2) / turbineParams.angularResolution);
                if (plotData.time.length < maxDataPoints) {
                    xMin = 0;
                    xMax = Math.min(lastTime, 4 * Math.PI); // Clip to data or 4œÄ, whichever is smaller
                } else {
                    // Once full, scroll with the data
                    xMin = firstTime;
                    xMax = lastTime;
                }
            }
            
            // Get current azimuth for position indicator
            const currentAzimuthDeg = ((rotorGroup.rotation.x * 180 / Math.PI) % 360);
            const normalizedCurrentAzimuth = currentAzimuthDeg >= 0 ? currentAzimuthDeg : currentAzimuthDeg + 360;
            
            // Update lift chart
            liftChart.data.labels = plotData.time;
            liftChart.options.scales.x.min = xMin;
            liftChart.options.scales.x.max = xMax;
            for (let i = 0; i < turbineParams.numBlades; i++) {
                if (liftChart.data.datasets[i] && displayBladeLift[i]) {
                    liftChart.data.datasets[i].data = displayBladeLift[i];
                }
            }
            if (liftChart.data.datasets[turbineParams.numBlades]) {
                liftChart.data.datasets[turbineParams.numBlades].data = displayTotalLift;
            }
            // Store current azimuth for drawing indicator
            liftChart.currentAzimuth = turbineParams.paused ? normalizedCurrentAzimuth : null;
            liftChart.update('none');
            
            // Update moment Y chart (nodding)
            momentYChart.data.labels = plotData.time;
            momentYChart.options.scales.x.min = xMin;
            momentYChart.options.scales.x.max = xMax;
            for (let i = 0; i < turbineParams.numBlades; i++) {
                if (momentYChart.data.datasets[i] && displayBladeMomentY[i]) {
                    momentYChart.data.datasets[i].data = displayBladeMomentY[i];
                }
            }
            if (momentYChart.data.datasets[turbineParams.numBlades]) {
                momentYChart.data.datasets[turbineParams.numBlades].data = displayTotalMomentY;
            }
            momentYChart.currentAzimuth = turbineParams.paused ? normalizedCurrentAzimuth : null;
            momentYChart.update('none');
            
            // Update moment Z chart (yawing)
            momentZChart.data.labels = plotData.time;
            momentZChart.options.scales.x.min = xMin;
            momentZChart.options.scales.x.max = xMax;
            for (let i = 0; i < turbineParams.numBlades; i++) {
                if (momentZChart.data.datasets[i] && displayBladeMomentZ[i]) {
                    momentZChart.data.datasets[i].data = displayBladeMomentZ[i];
                }
            }
            if (momentZChart.data.datasets[turbineParams.numBlades]) {
                momentZChart.data.datasets[turbineParams.numBlades].data = displayTotalMomentZ;
            }
            momentZChart.currentAzimuth = turbineParams.paused ? normalizedCurrentAzimuth : null;
            momentZChart.update('none');
            
            // Update Fourier analysis if we have enough data
            updateFourierDisplay();
        }
        
        // Update Fourier analysis display
        function updateFourierDisplay() {
            const thrustContent = document.getElementById('fourier-thrust-content');
            const momentYContent = document.getElementById('fourier-moment-y-content');
            const momentZContent = document.getElementById('fourier-moment-z-content');
            
            // Check if elements exist (they might not if we're still loading)
            if (!thrustContent || !momentYContent || !momentZContent) return;
            
            // Check collection status
            if (fourierData.collecting) {
                const mode = fourierData.fastMode ? ' (fast ' + fourierData.speedMultiplier + 'x)' : '';
                const statusMsg = '<p style="font-size: 0.85em; color: #999;">Collecting... (' + fourierData.bladeLift.length + ' pts)</p>';
                thrustContent.innerHTML = statusMsg;
                momentYContent.innerHTML = statusMsg;
                momentZContent.innerHTML = statusMsg;
                return;
            }
            
            if (!fourierData.complete || fourierData.bladeLift.length < 10) {
                const waitMsg = '<p style="font-size: 0.85em; color: #999;">Waiting...</p>';
                thrustContent.innerHTML = waitMsg;
                momentYContent.innerHTML = waitMsg;
                momentZContent.innerHTML = waitMsg;
                return;
            }
            
            // Use collected Fourier data
            const blade1Thrust = fourierData.bladeLift;
            const blade1MomentY = fourierData.bladeMomentY;
            const blade1MomentZ = fourierData.bladeMomentZ;
            const totalThrust = fourierData.totalLift;
            const totalMomentY = fourierData.totalMomentY;
            const totalMomentZ = fourierData.totalMomentZ;
            
            // Perform Fourier analysis (up to nP where n = numBlades)
            const maxHarmonic = Math.min(turbineParams.numBlades, 4);
            const blade1ThrustFourier = analyzeFourier(blade1Thrust, maxHarmonic);
            const blade1MomentYFourier = analyzeFourier(blade1MomentY, maxHarmonic);
            const blade1MomentZFourier = analyzeFourier(blade1MomentZ, maxHarmonic);
            const totalThrustFourier = analyzeFourier(totalThrust, maxHarmonic);
            const totalMomentYFourier = analyzeFourier(totalMomentY, maxHarmonic);
            const totalMomentZFourier = analyzeFourier(totalMomentZ, maxHarmonic);
            
            // Calculate percentages of total
            function calculatePercent(fourier) {
                const totalAmplitude = fourier.reduce((sum, h) => sum + Math.abs(h.amplitude), 0);
                return fourier.map(h => ({
                    ...h,
                    percent: totalAmplitude > 0 ? (Math.abs(h.amplitude) / totalAmplitude * 100) : 0
                }));
            }
            
            const blade1ThrustWithPercent = calculatePercent(blade1ThrustFourier);
            const totalThrustWithPercent = calculatePercent(totalThrustFourier);
            const blade1MomentYWithPercent = calculatePercent(blade1MomentYFourier);
            const blade1MomentZWithPercent = calculatePercent(blade1MomentZFourier);
            const totalMomentYWithPercent = calculatePercent(totalMomentYFourier);
            const totalMomentZWithPercent = calculatePercent(totalMomentZFourier);
            
            // Build HTML for each tab separately
            
            // Helper function to create Fourier series equation
            function createFourierEquation(label, fourier) {
                const A0 = fourier.find(h => h.harmonic === 0);
                const harmonics = fourier.filter(h => h.harmonic > 0);
                
                let eq = `<div style="background: #f0f0f0; padding: 8px; margin: 5px 0; border-radius: 4px; font-family: 'Courier New', monospace; font-size: 0.85em; overflow-x: auto;">`;
                eq += `<strong>${label} =</strong> `;
                
                if (A0) {
                    eq += `${A0.amplitude.toFixed(2)}`;
                } else {
                    eq += `0`;
                }
                
                harmonics.forEach((h, idx) => {
                    const sign = h.amplitude >= 0 ? ' + ' : ' - ';
                    const absAmp = Math.abs(h.amplitude).toFixed(2);
                    eq += `${sign}${absAmp}¬∑sin(${h.harmonic}œà)`;
                });
                
                eq += `</div>`;
                return eq;
            }
            
            // === THRUST TAB ===
            let thrustHtml = '';
            
            // Blade 1 Thrust
            thrustHtml += '<h5 style="margin: 10px 0 5px 0; font-size: 0.95em;">Blade 1 Thrust</h5>';
            thrustHtml += createFourierEquation('T', blade1ThrustFourier);
            thrustHtml += '<table style="width: 100%; font-size: 0.8em; border-collapse: collapse;">';
            thrustHtml += '<thead><tr style="background: #ddd;">';
            thrustHtml += '<th style="padding: 3px; text-align: center;">nP</th>';
            thrustHtml += '<th style="padding: 3px; text-align: right;">Amp</th>';
            thrustHtml += '<th style="padding: 3px; text-align: right;">%</th>';
            thrustHtml += '</tr></thead><tbody>';
            blade1ThrustWithPercent.forEach((h, idx) => {
                thrustHtml += `<tr style="background: ${idx % 2 === 0 ? '#f9f9f9' : '#fff'};">`;
                thrustHtml += `<td style="padding: 3px; text-align: center;">${h.harmonic}P</td>`;
                thrustHtml += `<td style="padding: 3px; text-align: right;">${h.amplitude.toFixed(2)}</td>`;
                thrustHtml += `<td style="padding: 3px; text-align: right;">${h.percent.toFixed(1)}%</td>`;
                thrustHtml += '</tr>';
            });
            thrustHtml += '</tbody></table>';
            
            // Total Rotor Thrust
            thrustHtml += '<h5 style="margin: 15px 0 5px 0; font-size: 0.95em;">Total Rotor Thrust</h5>';
            thrustHtml += createFourierEquation('T_total', totalThrustFourier);
            thrustHtml += '<table style="width: 100%; font-size: 0.8em; border-collapse: collapse;">';
            thrustHtml += '<thead><tr style="background: #ddd;">';
            thrustHtml += '<th style="padding: 3px; text-align: center;">nP</th>';
            thrustHtml += '<th style="padding: 3px; text-align: right;">Amp</th>';
            thrustHtml += '<th style="padding: 3px; text-align: right;">%</th>';
            thrustHtml += '</tr></thead><tbody>';
            totalThrustWithPercent.forEach((h, idx) => {
                thrustHtml += `<tr style="background: ${idx % 2 === 0 ? '#f9f9f9' : '#fff'};">`;
                thrustHtml += `<td style="padding: 3px; text-align: center;">${h.harmonic}P</td>`;
                thrustHtml += `<td style="padding: 3px; text-align: right;">${h.amplitude.toFixed(2)}</td>`;
                thrustHtml += `<td style="padding: 3px; text-align: right;">${h.percent.toFixed(1)}%</td>`;
                thrustHtml += '</tr>';
            });
            thrustHtml += '</tbody></table>';
            
            // === MOMENT Y TAB ===
            let momentYHtml = '';
            
            // Blade 1 Yawing Moment
            momentYHtml += '<h5 style="margin: 10px 0 5px 0; font-size: 0.95em;">Blade 1 M_y (Yawing)</h5>';
            momentYHtml += createFourierEquation('M_y', blade1MomentYFourier);
            momentYHtml += '<table style="width: 100%; font-size: 0.8em; border-collapse: collapse;">';
            momentYHtml += '<thead><tr style="background: #ddd;">';
            momentYHtml += '<th style="padding: 3px; text-align: center;">nP</th>';
            momentYHtml += '<th style="padding: 3px; text-align: right;">Amp</th>';
            momentYHtml += '<th style="padding: 3px; text-align: right;">%</th>';
            momentYHtml += '</tr></thead><tbody>';
            blade1MomentYWithPercent.forEach((h, idx) => {
                momentYHtml += `<tr style="background: ${idx % 2 === 0 ? '#f9f9f9' : '#fff'};">`;
                momentYHtml += `<td style="padding: 3px; text-align: center;">${h.harmonic}P</td>`;
                momentYHtml += `<td style="padding: 3px; text-align: right;">${h.amplitude.toFixed(2)}</td>`;
                momentYHtml += `<td style="padding: 3px; text-align: right;">${h.percent.toFixed(1)}%</td>`;
                momentYHtml += '</tr>';
            });
            momentYHtml += '</tbody></table>';
            
            // Total Rotor Yawing Moment
            momentYHtml += '<h5 style="margin: 15px 0 5px 0; font-size: 0.95em;">Total Rotor M_y (Yawing)</h5>';
            momentYHtml += createFourierEquation('M_y,total', totalMomentYFourier);
            momentYHtml += '<table style="width: 100%; font-size: 0.8em; border-collapse: collapse;">';
            momentYHtml += '<thead><tr style="background: #ddd;">';
            momentYHtml += '<th style="padding: 3px; text-align: center;">nP</th>';
            momentYHtml += '<th style="padding: 3px; text-align: right;">Amp</th>';
            momentYHtml += '<th style="padding: 3px; text-align: right;">%</th>';
            momentYHtml += '</tr></thead><tbody>';
            totalMomentYWithPercent.forEach((h, idx) => {
                momentYHtml += `<tr style="background: ${idx % 2 === 0 ? '#f9f9f9' : '#fff'};">`;
                momentYHtml += `<td style="padding: 3px; text-align: center;">${h.harmonic}P</td>`;
                momentYHtml += `<td style="padding: 3px; text-align: right;">${h.amplitude.toFixed(2)}</td>`;
                momentYHtml += `<td style="padding: 3px; text-align: right;">${h.percent.toFixed(1)}%</td>`;
                momentYHtml += '</tr>';
            });
            momentYHtml += '</tbody></table>';
            
            // === MOMENT Z TAB ===
            let momentZHtml = '';
            
            // Blade 1 Nodding Moment
            momentZHtml += '<h5 style="margin: 10px 0 5px 0; font-size: 0.95em;">Blade 1 M_z (Nodding)</h5>';
            momentZHtml += createFourierEquation('M_z', blade1MomentZFourier);
            momentZHtml += '<table style="width: 100%; font-size: 0.8em; border-collapse: collapse;">';
            momentZHtml += '<thead><tr style="background: #ddd;">';
            momentZHtml += '<th style="padding: 3px; text-align: center;">nP</th>';
            momentZHtml += '<th style="padding: 3px; text-align: right;">Amp</th>';
            momentZHtml += '<th style="padding: 3px; text-align: right;">%</th>';
            momentZHtml += '</tr></thead><tbody>';
            blade1MomentZWithPercent.forEach((h, idx) => {
                momentZHtml += `<tr style="background: ${idx % 2 === 0 ? '#f9f9f9' : '#fff'};">`;
                momentZHtml += `<td style="padding: 3px; text-align: center;">${h.harmonic}P</td>`;
                momentZHtml += `<td style="padding: 3px; text-align: right;">${h.amplitude.toFixed(2)}</td>`;
                momentZHtml += `<td style="padding: 3px; text-align: right;">${h.percent.toFixed(1)}%</td>`;
                momentZHtml += '</tr>';
            });
            momentZHtml += '</tbody></table>';
            
            // Total Rotor Nodding Moment
            momentZHtml += '<h5 style="margin: 15px 0 5px 0; font-size: 0.95em;">Total Rotor M_z (Nodding)</h5>';
            momentZHtml += createFourierEquation('M_z,total', totalMomentZFourier);
            momentZHtml += '<table style="width: 100%; font-size: 0.8em; border-collapse: collapse;">';
            momentZHtml += '<thead><tr style="background: #ddd;">';
            momentZHtml += '<th style="padding: 3px; text-align: center;">nP</th>';
            momentZHtml += '<th style="padding: 3px; text-align: right;">Amp</th>';
            momentZHtml += '<th style="padding: 3px; text-align: right;">%</th>';
            momentZHtml += '</tr></thead><tbody>';
            totalMomentZWithPercent.forEach((h, idx) => {
                momentZHtml += `<tr style="background: ${idx % 2 === 0 ? '#f9f9f9' : '#fff'};">`;
                momentZHtml += `<td style="padding: 3px; text-align: center;">${h.harmonic}P</td>`;
                momentZHtml += `<td style="padding: 3px; text-align: right;">${h.amplitude.toFixed(2)}</td>`;
                momentZHtml += `<td style="padding: 3px; text-align: right;">${h.percent.toFixed(1)}%</td>`;
                momentZHtml += '</tr>';
            });
            momentZHtml += '</tbody></table>';
            
            thrustContent.innerHTML = thrustHtml;
            momentYContent.innerHTML = momentYHtml;
            momentZContent.innerHTML = momentZHtml;
        }
        
        // Rebuild charts when blade count changes
        function rebuildCharts() {
            chartDatasets = createChartDatasets();
            
            // Completely rebuild lift chart
            liftChart.data.datasets = chartDatasets.liftDatasets;
            liftChart.data.labels = [];
            liftChart.update('reset');
            
            // Completely rebuild moment Y chart
            momentYChart.data.datasets = chartDatasets.momentYDatasets;
            momentYChart.data.labels = [];
            momentYChart.update('reset');
            
            // Completely rebuild moment Z chart
            momentZChart.data.datasets = chartDatasets.momentZDatasets;
            momentZChart.data.labels = [];
            momentZChart.update('reset');
        }
        
        // Create chart datasets
        function createChartDatasets() {
            const colors = [
                'rgb(255, 99, 132)',
                'rgb(54, 162, 235)',
                'rgb(75, 192, 192)',
                'rgb(255, 206, 86)',
                'rgb(153, 102, 255)',
                'rgb(255, 159, 64)',
                'rgb(199, 199, 199)',
                'rgb(83, 102, 255)',
                'rgb(255, 99, 255)',
                'rgb(99, 255, 132)',
                'rgb(255, 132, 99)',
                'rgb(132, 99, 255)',
                'rgb(99, 255, 255)',
                'rgb(255, 255, 99)',
                'rgb(192, 75, 192)',
                'rgb(75, 192, 75)',
                'rgb(192, 192, 75)',
                'rgb(75, 75, 192)',
                'rgb(192, 75, 75)',
                'rgb(128, 128, 128)'
            ];
            
            const liftDatasets = [];
            const momentYDatasets = [];
            const momentZDatasets = [];
            
            // Individual blade datasets
            for (let i = 0; i < turbineParams.numBlades; i++) {
                liftDatasets.push({
                    label: `Blade ${i + 1} Thrust`,
                    data: [],
                    borderColor: colors[i % colors.length],
                    backgroundColor: colors[i % colors.length],
                    borderWidth: 1,
                    pointRadius: 0
                });
                
                momentYDatasets.push({
                    label: `Blade ${i + 1} My`,
                    data: [],
                    borderColor: colors[i % colors.length],
                    backgroundColor: colors[i % colors.length],
                    borderWidth: 1,
                    pointRadius: 0
                });
                
                momentZDatasets.push({
                    label: `Blade ${i + 1} Mz`,
                    data: [],
                    borderColor: colors[i % colors.length],
                    backgroundColor: colors[i % colors.length],
                    borderWidth: 1,
                    pointRadius: 0
                });
            }
            
            // Total datasets
            liftDatasets.push({
                label: 'Total Thrust',
                data: [],
                borderColor: 'rgb(0, 0, 0)',
                backgroundColor: 'rgb(0, 0, 0)',
                borderWidth: 2,
                pointRadius: 0
            });
            
            momentYDatasets.push({
                label: 'Total My',
                data: [],
                borderColor: 'rgb(0, 0, 0)',
                backgroundColor: 'rgb(0, 0, 0)',
                borderWidth: 2,
                pointRadius: 0
            });
            
            momentZDatasets.push({
                label: 'Total Mz',
                data: [],
                borderColor: 'rgb(0, 0, 0)',
                backgroundColor: 'rgb(0, 0, 0)',
                borderWidth: 2,
                pointRadius: 0
            });
            
            return { liftDatasets, momentYDatasets, momentZDatasets };
        }
        
        // Initialize charts
        let chartDatasets = createChartDatasets();
        
        // Custom plugin to draw current position indicator
        const currentPositionPlugin = {
            id: 'currentPosition',
            afterDraw: (chart) => {
                if (chart.currentAzimuth !== null && chart.currentAzimuth !== undefined) {
                    const ctx = chart.ctx;
                    const xAxis = chart.scales.x;
                    const yAxis = chart.scales.y;
                    
                    // Find the x position for current azimuth
                    const labels = chart.data.labels;
                    let xPos = null;
                    
                    // Find closest label to current azimuth
                    let minDiff = Infinity;
                    let closestIndex = 0;
                    for (let i = 0; i < labels.length; i++) {
                        const labelValue = parseFloat(labels[i]);
                        const diff = Math.abs(labelValue - chart.currentAzimuth);
                        if (diff < minDiff) {
                            minDiff = diff;
                            closestIndex = i;
                        }
                    }
                    
                    if (closestIndex >= 0 && closestIndex < labels.length) {
                        xPos = xAxis.getPixelForValue(closestIndex);
                    }
                    
                    if (xPos !== null) {
                        ctx.save();
                        ctx.beginPath();
                        ctx.strokeStyle = 'rgba(255, 0, 0, 0.8)';
                        ctx.lineWidth = 2;
                        ctx.setLineDash([5, 5]);
                        ctx.moveTo(xPos, yAxis.top);
                        ctx.lineTo(xPos, yAxis.bottom);
                        ctx.stroke();
                        ctx.restore();
                    }
                }
            }
        };
        
        // Plugin to draw TDC (Top Dead Center) markers
        const tdcMarkerPlugin = {
            id: 'tdcMarker',
            afterDatasetsDraw(chart) {
                const { ctx, chartArea, scales } = chart;
                if (!chartArea || !plotData.tdcMarkers) return;
                
                ctx.save();
                ctx.strokeStyle = 'rgba(255, 0, 0, 0.6)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                
                plotData.tdcMarkers.forEach(tdcTime => {
                    const x = scales.x.getPixelForValue(tdcTime);
                    if (x >= chartArea.left && x <= chartArea.right) {
                        ctx.beginPath();
                        ctx.moveTo(x, chartArea.top);
                        ctx.lineTo(x, chartArea.bottom);
                        ctx.stroke();
                        
                        // Draw "TDC" label
                        ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
                        ctx.font = '10px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('TDC', x, chartArea.top - 5);
                    }
                });
                
                ctx.restore();
            }
        };
        
        const liftChartCtx = document.getElementById('lift-chart').getContext('2d');
        let liftChart = new Chart(liftChartCtx, {
            type: 'line',
            data: {
                labels: [],
                datasets: chartDatasets.liftDatasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Blade Thrust'
                    },
                    legend: {
                        display: true,
                        position: 'top'
                    }
                },
                scales: {
                    x: {
                        display: true,
                        type: 'linear',
                        title: {
                            display: true,
                            text: 'Time (rad)'
                        },
                        ticks: {
                            display: false  // Hide tick numbers
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Thrust'
                        }
                    }
                }
            },
            plugins: [currentPositionPlugin, tdcMarkerPlugin]
        });
        
        const momentYChartCtx = document.getElementById('moment-y-chart').getContext('2d');
        let momentYChart = new Chart(momentYChartCtx, {
            type: 'line',
            data: {
                labels: [],
                datasets: chartDatasets.momentYDatasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Nodding Moment (My)'
                    },
                    legend: {
                        display: true,
                        position: 'top'
                    }
                },
                scales: {
                    x: {
                        display: true,
                        type: 'linear',
                        title: {
                            display: true,
                            text: 'Time (rad)'
                        },
                        ticks: {
                            display: false  // Hide tick numbers
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Moment Y'
                        }
                    }
                }
            },
            plugins: [currentPositionPlugin, tdcMarkerPlugin]
        });
        
        const momentZChartCtx = document.getElementById('moment-z-chart').getContext('2d');
        let momentZChart = new Chart(momentZChartCtx, {
            type: 'line',
            data: {
                labels: [],
                datasets: chartDatasets.momentZDatasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Yawing Moment (Mz)'
                    },
                    legend: {
                        display: true,
                        position: 'top'
                    }
                },
                scales: {
                    x: {
                        display: true,
                        type: 'linear',
                        title: {
                            display: true,
                            text: 'Time (rad)'
                        },
                        ticks: {
                            display: false  // Hide tick numbers
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Moment Z'
                        }
                    }
                }
            },
            plugins: [currentPositionPlugin, tdcMarkerPlugin]
        });
        
        // Spanwise loading chart
        const spanwiseChartCanvas = document.getElementById('spanwise-chart');
        spanwiseChartCanvas.height = 450; // Set canvas height
        const spanwiseChartCtx = spanwiseChartCanvas.getContext('2d');
        let spanwiseChart = new Chart(spanwiseChartCtx, {
            type: 'line',
            data: {
                labels: [], // Will be % span positions
                datasets: [] // Will have multiple lines for different azimuths
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                scales: {
                    x: {
                        title: { display: true, text: 'Blade Span (%)' }
                    },
                    y: {
                        title: { display: true, text: 'Thrust (N/m)' },
                        beginAtZero: true
                    }
                },
                plugins: {
                    legend: { display: true, position: 'top' },
                    title: { display: false }
                }
            }
        });
        
        // Section analysis chart (for velocity vectors)
        const sectionChartCanvas = document.getElementById('section-chart');
        sectionChartCanvas.height = 400; // Set canvas height
        const sectionChartCtx = sectionChartCanvas.getContext('2d');
        let sectionChart = null; // Will be drawn manually with canvas 2D API
        
        // Now that charts are initialized, create the initial blades
        updateBladeCount();
        
        // Initial update of spanwise charts (after a short delay to ensure blades are created)
        setTimeout(() => {
            updateSpanwiseChart();
            updateSectionDiagram();
        }, 100);
        
        // Event listeners
        document.getElementById('wind-speed').addEventListener('input', (e) => {
            turbineParams.windSpeed = parseFloat(e.target.value);
            document.getElementById('wind-speed-value').textContent = turbineParams.windSpeed.toFixed(1);
            resetFourierCollection();
        });
        
        document.getElementById('shaft-speed').addEventListener('input', (e) => {
            turbineParams.shaftSpeed = parseFloat(e.target.value);
            document.getElementById('shaft-speed-value').textContent = turbineParams.shaftSpeed.toFixed(1);
            resetFourierCollection();
        });
        
        document.getElementById('pause-rotation').addEventListener('change', (e) => {
            turbineParams.paused = e.target.checked;
            if (turbineParams.paused) {
                // When pausing, set manual rotation to current rotation
                const currentRotationDeg = (rotorGroup.rotation.x * 180 / Math.PI) % 360;
                turbineParams.manualRotation = currentRotationDeg >= 0 ? currentRotationDeg : currentRotationDeg + 360;
                document.getElementById('manual-rotation').value = turbineParams.manualRotation;
                document.getElementById('manual-rotation-value').textContent = turbineParams.manualRotation.toFixed(1);
            }
        });
        
        document.getElementById('manual-rotation').addEventListener('input', (e) => {
            turbineParams.manualRotation = parseFloat(e.target.value);
            document.getElementById('manual-rotation-value').textContent = turbineParams.manualRotation.toFixed(1);
            if (turbineParams.paused) {
                // Directly set rotor rotation when paused
                rotorGroup.rotation.x = turbineParams.manualRotation * Math.PI / 180;
            }
        });
        
        document.getElementById('blade-pitch').addEventListener('input', (e) => {
            turbineParams.bladePitch = parseFloat(e.target.value);
            document.getElementById('blade-pitch-value').textContent = turbineParams.bladePitch.toFixed(1);
            // Update visual blade pitch
            blades.forEach(blade => {
                blade.pitchGroup.rotation.y = turbineParams.bladePitch * Math.PI / 180;
            });
        });
        
        document.getElementById('num-blades').addEventListener('input', (e) => {
            turbineParams.numBlades = parseInt(e.target.value);
            document.getElementById('num-blades-value').textContent = turbineParams.numBlades;
            updateBladeCount();
        });
        
        document.getElementById('yaw').addEventListener('input', (e) => {
            turbineParams.yawAngle = parseFloat(e.target.value);
            document.getElementById('yaw-value').textContent = turbineParams.yawAngle.toFixed(1);
            // Don't rotate nacelle - yaw now represents wind direction, turbine stays fixed
            resetFourierCollection();
        });
        
        document.getElementById('inflow').addEventListener('input', (e) => {
            turbineParams.inflowAngle = parseFloat(e.target.value);
            document.getElementById('inflow-value').textContent = turbineParams.inflowAngle.toFixed(1);
            resetFourierCollection();
        });
        
        document.getElementById('show-axes').addEventListener('change', (e) => {
            const show = e.target.checked;
            sceneAxes.visible = show;
            rotorAxes.visible = show;
            nacelleAxes.visible = show;
        });
        
        
        document.getElementById('wind-farm-mode').addEventListener('change', (e) => {
            turbineParams.windFarmMode = e.target.checked;
            createWindFarm();
        });
        
        document.getElementById('show-heatmap').addEventListener('change', (e) => {
            turbineParams.showHeatmap = e.target.checked;
        });
        
        document.getElementById('remove-mean').addEventListener('change', (e) => {
            turbineParams.removeMean = e.target.checked;
            resetFourierCollection();
        });
        
        document.getElementById('show-vectors').addEventListener('change', (e) => {
            turbineParams.showVectors = e.target.checked;
        });
        
        document.getElementById('vector-mode').addEventListener('change', (e) => {
            turbineParams.vectorMode = e.target.value;
            console.log('Vector mode changed to:', turbineParams.vectorMode);
        });
        
        document.getElementById('vector-scale').addEventListener('input', (e) => {
            turbineParams.vectorScale = parseFloat(e.target.value);
            document.getElementById('vector-scale-value').textContent = turbineParams.vectorScale.toFixed(3);
        });
        
        document.getElementById('angular-resolution').addEventListener('input', (e) => {
            turbineParams.angularResolution = parseFloat(e.target.value);
            const value = turbineParams.angularResolution;
            // Display with appropriate precision
            if (value < 1) {
                document.getElementById('angular-res-value').textContent = value.toFixed(3);
            } else {
                document.getElementById('angular-res-value').textContent = value.toFixed(1);
            }
            // Reset plot data when resolution changes
            initPlotData();
            rebuildCharts();
            for (let i = 0; i < turbineParams.numBlades; i++) {
                plotData.bladeLift[i] = [];
                plotData.bladeMomentY[i] = [];
                plotData.bladeMomentZ[i] = [];
            }
            timeCounter = 0;
            resetFourierCollection();
        });
        
        // Radial station control
        document.getElementById('radial-station').addEventListener('input', (e) => {
            const percent = parseInt(e.target.value);
            turbineParams.radialStation = percent / 100;
            document.getElementById('station-value').textContent = percent;
            // Reset plot data when station changes
            initPlotData();
            rebuildCharts();
            // Reset arrays
            for (let i = 0; i < turbineParams.numBlades; i++) {
                plotData.bladeLift[i] = [];
                plotData.bladeMomentY[i] = [];
                plotData.bladeMomentZ[i] = [];
            }
            timeCounter = 0;
        });
                
        // Debug data generation
        document.getElementById('generate-debug').addEventListener('click', () => {
            generateDebugData();
        });
        
        // Generate debug table for 2-blade turbine
        function generateDebugData() {
            const output = document.getElementById('debug-output');
            
            output.innerHTML = '<p>Generating debug data for 2-blade turbine...</p>';
            output.innerHTML += `<p><strong>Configuration:</strong> Wind Speed=${turbineParams.windSpeed.toFixed(1)} m/s, Shaft Speed=${turbineParams.shaftSpeed.toFixed(1)} RPM, Yaw=${turbineParams.yawAngle}¬∞, Inflow=${turbineParams.inflowAngle}¬∞</p>`;
            output.innerHTML += `<p><strong>Radial Station:</strong> ${(turbineParams.radialStation * 100).toFixed(0)}% span</p>`;
            
            // Axis system info
            output.innerHTML += '<hr>';
            output.innerHTML += '<h3>Coordinate System</h3>';
            output.innerHTML += '<p><strong>THREE.js Convention:</strong> X-axis points downstream (into wind), Y-axis points up, Z-axis to the side</p>';
            output.innerHTML += '<p><strong>Rotor:</strong> Rotates about X-axis. rotation.x = angle</p>';
            output.innerHTML += '<p><strong>Blade positioning:</strong></p>';
            output.innerHTML += '<ul>';
            output.innerHTML += '<li>rotation.x = 0 ‚Üí Blade at Y+ (top of disc, 12 o\'clock)</li>';
            output.innerHTML += '<li>rotation.x = œÄ/2 ‚Üí Blade at Z+ (3 o\'clock looking downstream)</li>';
            output.innerHTML += '<li>rotation.x = œÄ ‚Üí Blade at Y- (bottom of disc, 6 o\'clock)</li>';
            output.innerHTML += '<li>rotation.x = 3œÄ/2 ‚Üí Blade at Z- (9 o\'clock looking downstream)</li>';
            output.innerHTML += '</ul>';
            output.innerHTML += '<p><strong>Expected with Yaw:</strong> Peak thrust when blade is on advancing side (Z+), minimum on retreating side (Z-)</p>';
            output.innerHTML += '<hr>';
            
            // Calculate thrust for 2 revolutions at 10-degree intervals
            const debugData = [];
            const omega = turbineParams.shaftSpeed * 2 * Math.PI / 60;
            const windSpeed = turbineParams.windSpeed;
            const yawRadians = turbineParams.yawAngle * Math.PI / 180;
            const inflowRadians = turbineParams.inflowAngle * Math.PI / 180;
            const windSpeedAxial = windSpeed * Math.cos(yawRadians);
            const windSpeedTangential = windSpeed * Math.sin(yawRadians);
            const targetRadius = turbineParams.radialStation * turbineParams.bladeRadius;
            
            // Get the chord at target radius (approximate from blade segments)
            let chord = 1.0; // default
            if (blades.length > 0 && blades[0].segments.length > 0) {
                let closestSegment = blades[0].segments[0];
                let minDist = Infinity;
                blades[0].segments.forEach(segment => {
                    const dist = Math.abs(segment.userData.radius - targetRadius);
                    if (dist < minDist) {
                        minDist = dist;
                        closestSegment = segment;
                    }
                });
                chord = closestSegment.userData.chord;
            }
            
            // Calculate for 2 revolutions at 10-degree resolution
            for (let angleDeg = 0; angleDeg < 720; angleDeg += 10) {
                const angle = angleDeg * Math.PI / 180;
                
                // Blade 1 azimuth (starts at 0)
                const azimuth1 = angle;
                const thrust1 = calculateThrustAtAzimuth(azimuth1, targetRadius, chord, omega, windSpeedAxial, windSpeedTangential, inflowRadians);
                
                // Blade 2 azimuth (180 degrees offset)
                const azimuth2 = angle + Math.PI;
                const thrust2 = calculateThrustAtAzimuth(azimuth2, targetRadius, chord, omega, windSpeedAxial, windSpeedTangential, inflowRadians);
                
                // Position descriptions
                const pos1 = getPositionDescription((azimuth1 * 180 / Math.PI) % 360);
                const pos2 = getPositionDescription((azimuth2 * 180 / Math.PI) % 360);
                
                debugData.push({
                    angle: angleDeg,
                    azimuth1Deg: (azimuth1 * 180 / Math.PI) % 360,
                    azimuth2Deg: (azimuth2 * 180 / Math.PI) % 360,
                    thrust1: thrust1,
                    thrust2: thrust2,
                    diff: Math.abs(thrust1 - thrust2),
                    pos1: pos1,
                    pos2: pos2
                });
            }
            
            // Find crossings (where thrust1 and thrust2 are approximately equal)
            const crossings = [];
            for (let i = 1; i < debugData.length; i++) {
                const prev = debugData[i-1];
                const curr = debugData[i];
                
                // Check if lines cross (sign change in difference)
                if ((prev.thrust1 - prev.thrust2) * (curr.thrust1 - curr.thrust2) < 0) {
                    // Linear interpolation to find exact crossing
                    const t = Math.abs(prev.thrust1 - prev.thrust2) / (Math.abs(prev.thrust1 - prev.thrust2) + Math.abs(curr.thrust1 - curr.thrust2));
                    const crossAngle = prev.angle + t * (curr.angle - prev.angle);
                    const crossThrust = prev.thrust1 + t * (curr.thrust1 - prev.thrust1);
                    crossings.push({ angle: crossAngle, thrust: crossThrust });
                }
            }
            
            // Build HTML table
            let html = '<h3>Debug Data Table</h3>';
            html += '<table style="border-collapse: collapse; width: 100%; font-size: 0.85em;">';
            html += '<thead><tr style="background: #667eea; color: white;">';
            html += '<th style="border: 1px solid #ddd; padding: 8px;">Rotor Angle</th>';
            html += '<th style="border: 1px solid #ddd; padding: 8px;">Blade 1 Az</th>';
            html += '<th style="border: 1px solid #ddd; padding: 8px;">Position</th>';
            html += '<th style="border: 1px solid #ddd; padding: 8px;">Blade 1 Thrust</th>';
            html += '<th style="border: 1px solid #ddd; padding: 8px;">Blade 2 Az</th>';
            html += '<th style="border: 1px solid #ddd; padding: 8px;">Position</th>';
            html += '<th style="border: 1px solid #ddd; padding: 8px;">Blade 2 Thrust</th>';
            html += '<th style="border: 1px solid #ddd; padding: 8px;">|Diff|</th>';
            html += '</tr></thead><tbody>';
            
            debugData.forEach((row, idx) => {
                const bgColor = idx % 2 === 0 ? '#f9f9f9' : '#ffffff';
                html += `<tr style="background: ${bgColor};">`;
                html += `<td style="border: 1px solid #ddd; padding: 6px; text-align: center;">${row.angle.toFixed(0)}¬∞</td>`;
                html += `<td style="border: 1px solid #ddd; padding: 6px; text-align: center;">${row.azimuth1Deg.toFixed(1)}¬∞</td>`;
                html += `<td style="border: 1px solid #ddd; padding: 6px; text-align: center; font-size: 0.8em;">${row.pos1}</td>`;
                html += `<td style="border: 1px solid #ddd; padding: 6px; text-align: right; font-weight: bold;">${row.thrust1.toFixed(3)}</td>`;
                html += `<td style="border: 1px solid #ddd; padding: 6px; text-align: center;">${row.azimuth2Deg.toFixed(1)}¬∞</td>`;
                html += `<td style="border: 1px solid #ddd; padding: 6px; text-align: center; font-size: 0.8em;">${row.pos2}</td>`;
                html += `<td style="border: 1px solid #ddd; padding: 6px; text-align: right; font-weight: bold;">${row.thrust2.toFixed(3)}</td>`;
                html += `<td style="border: 1px solid #ddd; padding: 6px; text-align: right; color: ${row.diff < 0.1 ? 'green' : 'black'};">${row.diff.toFixed(3)}</td>`;
                html += '</tr>';
            });
            
            html += '</tbody></table>';
            
            // Add crossings info
            html += '<h3 style="margin-top: 20px;">Crossings (where Thrust1 ‚âà Thrust2)</h3>';
            if (turbineParams.yawAngle === 0 && turbineParams.inflowAngle === 0) {
                html += '<p><strong>Expected with no yaw/inflow:</strong> Thrusts should be equal everywhere (constant), so any "crossings" are numerical artifacts.</p>';
            } else {
                html += '<p><strong>Expected with yaw or inflow:</strong> Crossings at 90¬∞ and 270¬∞ (advancing/retreating sides)</p>';
            }
            if (crossings.length > 0) {
                html += '<ul>';
                crossings.forEach((cross, idx) => {
                    const expected = 90 + idx * 180;
                    const error = cross.angle - expected;
                    html += `<li>Crossing ${idx+1}: <strong>${cross.angle.toFixed(2)}¬∞</strong> (thrust=${cross.thrust.toFixed(3)}) - Expected: ${expected}¬∞ - <span style="color: ${Math.abs(error) < 5 ? 'green' : 'red'};">Error: ${error.toFixed(2)}¬∞</span></li>`;
                });
                html += '</ul>';
            } else {
                html += '<p style="color: red;">No crossings found!</p>';
            }
            
            // Fourier Analysis
            html += '<h3 style="margin-top: 30px;">Fourier Analysis (Harmonics)</h3>';
            html += '<p>Decomposition into 0P (mean), 1P, 2P, 3P, and 4P harmonics</p>';
            
            // Extract one full revolution for each blade
            const blade1Thrust = [];
            const blade2Thrust = [];
            const blade1MomentY = [];
            const blade2MomentY = [];
            const blade1MomentZ = [];
            const blade2MomentZ = [];
            
            for (let i = 0; i < 36; i++) { // 0-360 degrees in 10-degree steps
                const row = debugData[i];
                blade1Thrust.push(row.thrust1);
                blade2Thrust.push(row.thrust2);
                
                // Calculate moments (same as in updatePlotData)
                const azimuth1 = row.azimuth1Deg * Math.PI / 180;
                const azimuth2 = row.azimuth2Deg * Math.PI / 180;
                const r = targetRadius;
                
                blade1MomentY.push(row.thrust1 * r * Math.sin(azimuth1));
                blade1MomentZ.push(-row.thrust1 * r * Math.cos(azimuth1));
                blade2MomentY.push(row.thrust2 * r * Math.sin(azimuth2));
                blade2MomentZ.push(-row.thrust2 * r * Math.cos(azimuth2));
            }
            
            // Perform Fourier analysis
            const blade1ThrustFourier = analyzeFourier(blade1Thrust);
            const blade2ThrustFourier = analyzeFourier(blade2Thrust);
            const blade1MomentYFourier = analyzeFourier(blade1MomentY);
            const blade2MomentYFourier = analyzeFourier(blade2MomentY);
            const blade1MomentZFourier = analyzeFourier(blade1MomentZ);
            const blade2MomentZFourier = analyzeFourier(blade2MomentZ);
            
            // Display results
            html += '<h4>Blade 1 Thrust</h4>';
            html += '<table style="border-collapse: collapse; font-size: 0.9em; margin-bottom: 15px;">';
            html += '<thead><tr style="background: #667eea; color: white;">';
            html += '<th style="border: 1px solid #ddd; padding: 6px;">Harmonic</th>';
            html += '<th style="border: 1px solid #ddd; padding: 6px;">Amplitude</th>';
            html += '<th style="border: 1px solid #ddd; padding: 6px;">Phase (deg)</th>';
            html += '</tr></thead><tbody>';
            blade1ThrustFourier.forEach((h, idx) => {
                const bgColor = idx % 2 === 0 ? '#f9f9f9' : '#ffffff';
                html += `<tr style="background: ${bgColor};">`;
                html += `<td style="border: 1px solid #ddd; padding: 6px; text-align: center;">${h.harmonic}P</td>`;
                html += `<td style="border: 1px solid #ddd; padding: 6px; text-align: right;">${h.amplitude.toFixed(3)}</td>`;
                html += `<td style="border: 1px solid #ddd; padding: 6px; text-align: right;">${h.phase.toFixed(1)}¬∞</td>`;
                html += '</tr>';
            });
            html += '</tbody></table>';
            
            html += '<h4>Blade 2 Thrust</h4>';
            html += '<table style="border-collapse: collapse; font-size: 0.9em; margin-bottom: 15px;">';
            html += '<thead><tr style="background: #667eea; color: white;">';
            html += '<th style="border: 1px solid #ddd; padding: 6px;">Harmonic</th>';
            html += '<th style="border: 1px solid #ddd; padding: 6px;">Amplitude</th>';
            html += '<th style="border: 1px solid #ddd; padding: 6px;">Phase (deg)</th>';
            html += '</tr></thead><tbody>';
            blade2ThrustFourier.forEach((h, idx) => {
                const bgColor = idx % 2 === 0 ? '#f9f9f9' : '#ffffff';
                html += `<tr style="background: ${bgColor};">`;
                html += `<td style="border: 1px solid #ddd; padding: 6px; text-align: center;">${h.harmonic}P</td>`;
                html += `<td style="border: 1px solid #ddd; padding: 6px; text-align: right;">${h.amplitude.toFixed(3)}</td>`;
                html += `<td style="border: 1px solid #ddd; padding: 6px; text-align: right;">${h.phase.toFixed(1)}¬∞</td>`;
                html += '</tr>';
            });
            html += '</tbody></table>';
            
            html += '<h4>Blade 1 Yawing Moment (M_y)</h4>';
            html += '<table style="border-collapse: collapse; font-size: 0.9em; margin-bottom: 15px;">';
            html += '<thead><tr style="background: #667eea; color: white;">';
            html += '<th style="border: 1px solid #ddd; padding: 6px;">Harmonic</th>';
            html += '<th style="border: 1px solid #ddd; padding: 6px;">Amplitude</th>';
            html += '<th style="border: 1px solid #ddd; padding: 6px;">Phase (deg)</th>';
            html += '</tr></thead><tbody>';
            blade1MomentYFourier.forEach((h, idx) => {
                const bgColor = idx % 2 === 0 ? '#f9f9f9' : '#ffffff';
                html += `<tr style="background: ${bgColor};">`;
                html += `<td style="border: 1px solid #ddd; padding: 6px; text-align: center;">${h.harmonic}P</td>`;
                html += `<td style="border: 1px solid #ddd; padding: 6px; text-align: right;">${h.amplitude.toFixed(3)}</td>`;
                html += `<td style="border: 1px solid #ddd; padding: 6px; text-align: right;">${h.phase.toFixed(1)}¬∞</td>`;
                html += '</tr>';
            });
            html += '</tbody></table>';
            
            html += '<h4>Blade 1 Nodding Moment (M_z)</h4>';
            html += '<table style="border-collapse: collapse; font-size: 0.9em; margin-bottom: 15px;">';
            html += '<thead><tr style="background: #667eea; color: white;">';
            html += '<th style="border: 1px solid #ddd; padding: 6px;">Harmonic</th>';
            html += '<th style="border: 1px solid #ddd; padding: 6px;">Amplitude</th>';
            html += '<th style="border: 1px solid #ddd; padding: 6px;">Phase (deg)</th>';
            html += '</tr></thead><tbody>';
            blade1MomentZFourier.forEach((h, idx) => {
                const bgColor = idx % 2 === 0 ? '#f9f9f9' : '#ffffff';
                html += `<tr style="background: ${bgColor};">`;
                html += `<td style="border: 1px solid #ddd; padding: 6px; text-align: center;">${h.harmonic}P</td>`;
                html += `<td style="border: 1px solid #ddd; padding: 6px; text-align: right;">${h.amplitude.toFixed(3)}</td>`;
                html += `<td style="border: 1px solid #ddd; padding: 6px; text-align: right;">${h.phase.toFixed(1)}¬∞</td>`;
                html += '</tr>';
            });
            html += '</tbody></table>';
            
            output.innerHTML = html;
        }
        
        // Update spanwise loading chart
        function updateSpanwiseChart() {
            if (!blades || blades.length === 0) {
                console.log('updateSpanwiseChart: No blades available');
                return;
            }
            
            const blade = blades[0]; // Use primary blade
            if (!blade.children || blade.children.length === 0) {
                console.log('updateSpanwiseChart: Blade has no children');
                return;
            }
            
            console.log('updateSpanwiseChart: Processing', blade.children.length, 'segments');
            
            const currentAzimuth = (rotorGroup.rotation.x * 180 / Math.PI) % 360;
            
            // Sample azimuths to show (every 45 degrees)
            const sampleAzimuths = [0, 45, 90, 135, 180, 225, 270, 315];
            
            // Get spanwise positions
            const spanPositions = [];
            const thrustAtAzimuths = {}; // { azimuth: [thrust values along span] }
            
            blade.children.forEach((segment, idx) => {
                const r = turbineParams.bladeRadius * (0.1 + 0.9 * idx / blade.children.length);
                const spanPercent = (r / turbineParams.bladeRadius * 100);
                spanPositions.push(spanPercent);
            });
            
            // Calculate thrust for each azimuth
            sampleAzimuths.forEach(azimuth => {
                thrustAtAzimuths[azimuth] = blade.children.map(segment => {
                    const r = segment.userData.radius || 0;
                    const chord = segment.userData.chord || 0;
                    const twist = segment.userData.twist || 0;
                    const azimuthRad = azimuth * Math.PI / 180;
                    
                    // Calculate velocity components
                    const V = turbineParams.windSpeed;
                    const inflowRadians = turbineParams.inflowAngle * Math.PI / 180;
                    const yawRadians = turbineParams.yawAngle * Math.PI / 180;
                    
                    const V_x = V * Math.sin(yawRadians);
                    const V_y = V * Math.sin(inflowRadians) * Math.cos(yawRadians);
                    const V_z = V * Math.cos(inflowRadians) * Math.cos(yawRadians);
                    
                    const omega = turbineParams.shaftSpeed * 2 * Math.PI / 60;
                    const U = omega * r;
                    
                    const V_inplane_tangential = V_x * Math.cos(azimuthRad) - V_y * Math.sin(azimuthRad);
                    const V_normal = V_z;
                    
                    const Vt = U - V_inplane_tangential;
                    const Vn = V_normal;
                    const V_total = Math.sqrt(Vt * Vt + Vn * Vn);
                    
                    const phi = Math.atan2(Vn, Vt);
                    const aoa = twist - phi * 180 / Math.PI;
                    
                    const Cl = 2 * Math.PI * aoa * Math.PI / 180;
                    const Cd = 0.01;
                    
                    const L = 0.5 * 1.225 * V_total * V_total * chord * Cl;
                    const D = 0.5 * 1.225 * V_total * V_total * chord * Cd;
                    
                    const thrust_per_unit = L * Math.cos(phi) + D * Math.sin(phi);
                    
                    return thrust_per_unit;
                });
            });
            
            // Update chart
            spanwiseChart.data.labels = spanPositions.map(p => p.toFixed(0));
            spanwiseChart.data.datasets = sampleAzimuths.map((azimuth, idx) => {
                const colors = ['#ff6384', '#36a2eb', '#ffce56', '#4bc0c0', '#9966ff', '#ff9f40', '#ff6384', '#c9cbcf'];
                return {
                    label: `œà = ${azimuth}¬∞`,
                    data: thrustAtAzimuths[azimuth],
                    borderColor: colors[idx % colors.length],
                    backgroundColor: 'transparent',
                    borderWidth: 2,
                    pointRadius: 3,
                    tension: 0.2
                };
            });
            
            console.log('updateSpanwiseChart: Updated chart with', spanwiseChart.data.datasets.length, 'datasets,', spanwiseChart.data.labels.length, 'points');
            spanwiseChart.update('none');
        }
        
        // Update section diagram with velocity vectors
        function updateSectionDiagram() {
            const canvas = document.getElementById('section-chart');
            if (!canvas) {
                console.log('updateSectionDiagram: Canvas not found');
                return;
            }
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width = canvas.offsetWidth;
            const height = canvas.height = 400;
            
            console.log('updateSectionDiagram: Canvas size', width, 'x', height);
            
            ctx.clearRect(0, 0, width, height);
            
            // Get current radial station from load traces slider
            const stationPercent = parseFloat(document.getElementById('radial-station').value);
            const r = turbineParams.bladeRadius * stationPercent / 100;
            
            // Get blade segment at this station
            if (!blades || blades.length === 0) return;
            const blade = blades[0];
            const segmentIndex = Math.floor((stationPercent - 10) / 85 * blade.children.length);
            const segment = blade.children[Math.max(0, Math.min(segmentIndex, blade.children.length - 1))];
            
            if (!segment) return;
            
            const chord = segment.userData.chord || 1;
            const twist = segment.userData.twist || 0;
            const azimuth = (rotorGroup.rotation.x * 180 / Math.PI) % 360;
            const azimuthRad = azimuth * Math.PI / 180;
            
            // Calculate velocity components
            const V = turbineParams.windSpeed;
            const inflowRadians = turbineParams.inflowAngle * Math.PI / 180;
            const yawRadians = turbineParams.yawAngle * Math.PI / 180;
            
            const V_x = V * Math.sin(yawRadians);
            const V_y = V * Math.sin(inflowRadians) * Math.cos(yawRadians);
            const V_z = V * Math.cos(inflowRadians) * Math.cos(yawRadians);
            
            const omega = turbineParams.shaftSpeed * 2 * Math.PI / 60;
            const U = omega * r;
            
            const V_inplane_tangential = V_x * Math.cos(azimuthRad) - V_y * Math.sin(azimuthRad);
            const V_normal = V_z;
            
            const Vt = U - V_inplane_tangential;
            const Vn = V_normal;
            const V_total = Math.sqrt(Vt * Vt + Vn * Vn);
            
            const phi = Math.atan2(Vn, Vt);
            const aoa = twist - phi * 180 / Math.PI;
            
            const Cl = 2 * Math.PI * aoa * Math.PI / 180;
            const Cd = 0.01;
            
            const L = 0.5 * 1.225 * V_total * V_total * chord * Cl;
            const D = 0.5 * 1.225 * V_total * V_total * chord * Cd;
            
            const thrust = L * Math.cos(phi) + D * Math.sin(phi);
            
            // Update info panel
            document.getElementById('section-azimuth').textContent = azimuth.toFixed(1) + '¬∞';
            document.getElementById('section-aoa').textContent = aoa.toFixed(1) + '¬∞';
            document.getElementById('section-vtotal').textContent = V_total.toFixed(2) + ' m/s';
            document.getElementById('section-vtang').textContent = Vt.toFixed(2) + ' m/s';
            document.getElementById('section-vnorm').textContent = Vn.toFixed(2) + ' m/s';
            document.getElementById('section-thrust').textContent = thrust.toFixed(2) + ' N';
            
            // Draw airfoil section (simplified NACA shape)
            const centerX = width / 2;
            const centerY = height / 2;
            const chordScale = 100; // pixels per unit chord
            const chordLength = chord * chordScale;
            
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.rotate(-twist * Math.PI / 180); // Apply twist
            
            // Draw airfoil
            ctx.beginPath();
            ctx.moveTo(-chordLength/2, 0);
            for (let i = 0; i <= 100; i++) {
                const x = -chordLength/2 + i * chordLength / 100;
                const xNorm = i / 100;
                // Simple symmetric airfoil shape
                const y = chordLength * 0.12 * (0.2969 * Math.sqrt(xNorm) - 0.126 * xNorm - 0.3516 * xNorm * xNorm + 0.2843 * xNorm * xNorm * xNorm - 0.1015 * xNorm * xNorm * xNorm * xNorm);
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            for (let i = 100; i >= 0; i--) {
                const x = -chordLength/2 + i * chordLength / 100;
                const xNorm = i / 100;
                const y = -chordLength * 0.12 * (0.2969 * Math.sqrt(xNorm) - 0.126 * xNorm - 0.3516 * xNorm * xNorm + 0.2843 * xNorm * xNorm * xNorm - 0.1015 * xNorm * xNorm * xNorm * xNorm);
                ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fillStyle = '#ddd';
            ctx.fill();
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw chord line
            ctx.beginPath();
            ctx.moveTo(-chordLength/2, 0);
            ctx.lineTo(chordLength/2, 0);
            ctx.strokeStyle = '#999';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.stroke();
            ctx.setLineDash([]);
            
            ctx.restore();
            
            // Draw velocity vectors (in global frame)
            const vectorScale = 3; // pixels per m/s
            const vecOriginX = centerX;
            const vecOriginY = centerY;
            
            // V_tangential (horizontal, to the left in rotor frame)
            drawVector(ctx, vecOriginX, vecOriginY, -Vt * vectorScale, 0, '#ff6384', 'V_t');
            
            // V_normal (vertical, upward is positive inflow)
            drawVector(ctx, vecOriginX, vecOriginY, 0, -Vn * vectorScale, '#36a2eb', 'V_n');
            
            // V_total (resultant)
            drawVector(ctx, vecOriginX, vecOriginY, -Vt * vectorScale, -Vn * vectorScale, '#4bc0c0', 'V_total', 3);
            
            // Draw angle of attack reference
            ctx.save();
            ctx.translate(vecOriginX, vecOriginY);
            ctx.rotate(-twist * Math.PI / 180);
            
            // Draw angle arc
            const arcRadius = 40;
            ctx.beginPath();
            ctx.arc(0, 0, arcRadius, 0, -phi, phi < 0);
            ctx.strokeStyle = '#9966ff';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Label AoA
            const midAngle = -phi / 2;
            const labelX = arcRadius * 1.3 * Math.cos(midAngle);
            const labelY = arcRadius * 1.3 * Math.sin(midAngle);
            ctx.font = '14px Arial';
            ctx.fillStyle = '#9966ff';
            ctx.fillText('œÜ', labelX, labelY);
            
            ctx.restore();
        }
        
        // Helper function to draw labeled vector
        function drawVector(ctx, x, y, dx, dy, color, label, width = 2) {
            const length = Math.sqrt(dx * dx + dy * dy);
            if (length < 1) return;
            
            const angle = Math.atan2(dy, dx);
            const headLength = 10;
            
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x + dx, y + dy);
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            ctx.stroke();
            
            // Arrowhead
            ctx.beginPath();
            ctx.moveTo(x + dx, y + dy);
            ctx.lineTo(x + dx - headLength * Math.cos(angle - Math.PI / 6), y + dy - headLength * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(x + dx - headLength * Math.cos(angle + Math.PI / 6), y + dy - headLength * Math.sin(angle + Math.PI / 6));
            ctx.closePath();
            ctx.fillStyle = color;
            ctx.fill();
            
            // Label
            ctx.font = 'bold 14px Arial';
            ctx.fillStyle = color;
            const labelOffset = 15;
            const labelX = x + dx + labelOffset * Math.cos(angle);
            const labelY = y + dy + labelOffset * Math.sin(angle);
            ctx.fillText(label, labelX, labelY);
        }
        
        // Perform DFT analysis on a signal
        function analyzeFourier(signal, maxHarmonic = 4) {
            const N = signal.length;
            const results = [];
            
            for (let k = 0; k <= maxHarmonic; k++) {
                let real = 0;
                let imag = 0;
                
                for (let n = 0; n < N; n++) {
                    const angle = (2 * Math.PI * k * n) / N;
                    real += signal[n] * Math.cos(angle);
                    imag += signal[n] * Math.sin(angle);
                }
                
                real /= N;
                imag /= N;
                
                // For k > 0, multiply by 2 to get amplitude (since we only look at positive frequencies)
                const amplitude = k === 0 ? real : 2 * Math.sqrt(real * real + imag * imag);
                const phase = Math.atan2(imag, real) * 180 / Math.PI;
                
                results.push({
                    harmonic: k,
                    amplitude: amplitude,
                    phase: phase,
                    real: real,
                    imag: imag
                });
            }
            
            return results;
        }
        
        // Helper to describe blade position
        function getPositionDescription(azimuthDeg) {
            if (azimuthDeg < 45 || azimuthDeg >= 315) return '‚Üë Top';
            if (azimuthDeg >= 45 && azimuthDeg < 135) return '‚Üí Adv';
            if (azimuthDeg >= 135 && azimuthDeg < 225) return '‚Üì Bot';
            return '‚Üê Ret';
        }
        
        // Helper function to calculate thrust at a given azimuth
        function calculateThrustAtAzimuth(azimuth, r, chord, omega, windSpeedAxial, windSpeedTangential, inflowRadians) {
            // Blade twist distribution (typical for wind turbine)
            const r_norm = (r - turbineParams.hubRadius) / (turbineParams.bladeRadius - turbineParams.hubRadius);
            const twist = 14 * (1 - r_norm); // Linear twist from 14¬∞ at root to 0¬∞ at tip
            
            // Velocities in rotor disc coordinates
            // Use proper coordinate transformation
            const V = turbineParams.windSpeed;
            const alpha = inflowRadians;
            const beta = turbineParams.yawAngle * Math.PI / 180;
            
            const V_x = V * Math.sin(beta);
            const V_y = V * Math.sin(alpha) * Math.cos(beta);
            const V_z = V * Math.cos(alpha) * Math.cos(beta);
            
            // In-plane velocity component at blade azimuth (perpendicular to radius)
            const V_inplane_tangential = V_x * Math.cos(azimuth) - V_y * Math.sin(azimuth);
            
            // Tangential velocity (rotation + in-plane wind)
            const Vt = omega * r + V_inplane_tangential;
            
            // Normal velocity (axial wind + induction)
            const Vn = -V_z * (1 - 0.3);
            
            // Flow angle and angle of attack
            const phi = Math.atan2(Vn, Vt);
            const aoa = -(phi * 180 / Math.PI - twist + turbineParams.bladePitch);
            
            // Dynamic pressure
            const V_total = Math.sqrt(Vt * Vt + Vn * Vn);
            const q = 0.5 * 1.225 * V_total * V_total * chord * (turbineParams.bladeRadius / 100);
            
            // Simple aerodynamic model
            const Cl = 2 * Math.PI * Math.sin(aoa * Math.PI / 180);
            const L = q * Cl;
            const D = 0.05 * Math.abs(L);
            
            // Thrust (axial force)
            const thrust = L * Math.cos(phi) + D * Math.sin(phi);
            return thrust;
        }
        
        // Make panels draggable (only by their headers)
        function makeDraggable(element, handleSelector) {
            let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
            
            // Get the header element if selector provided, otherwise use the whole element
            const handle = handleSelector ? element.querySelector(handleSelector) : element;
            
            if (handle) {
                handle.onmousedown = dragMouseDown;
                handle.style.cursor = 'move';
            }
            
            function dragMouseDown(e) {
                // Don't drag if clicking on a button
                if (e.target.tagName === 'BUTTON') {
                    return;
                }
                e.preventDefault();
                pos3 = e.clientX;
                pos4 = e.clientY;
                document.onmouseup = closeDragElement;
                document.onmousemove = elementDrag;
                // Clear bottom positioning to prevent height stretching when both top and bottom are set
                element.style.bottom = '';
            }
            
            function elementDrag(e) {
                e.preventDefault();
                pos1 = pos3 - e.clientX;
                pos2 = pos4 - e.clientY;
                pos3 = e.clientX;
                pos4 = e.clientY;
                element.style.top = (element.offsetTop - pos2) + "px";
                element.style.left = (element.offsetLeft - pos1) + "px";
            }
            
            function closeDragElement() {
                document.onmouseup = null;
                document.onmousemove = null;
            }
        }
        
        makeDraggable(document.getElementById('controls-panel'), '.panel-header');
        makeDraggable(document.getElementById('stats'), 'h3');
        makeDraggable(document.getElementById('legend'), 'h3');
        makeDraggable(document.getElementById('plot-panel'), '.plot-header');
        makeDraggable(document.getElementById('spanwise-panel'), '.plot-header');
        
        // Minimize controls panel
        document.getElementById('minimize-btn').addEventListener('click', () => {
            const panel = document.getElementById('controls-panel');
            const btn = document.getElementById('minimize-btn');
            panel.classList.toggle('minimized');
            btn.textContent = panel.classList.contains('minimized') ? '+' : '‚àí';
        });
        
        // Minimize plot panel
        document.getElementById('minimize-plot-btn').addEventListener('click', () => {
            const panel = document.getElementById('plot-panel');
            const btn = document.getElementById('minimize-plot-btn');
            panel.classList.toggle('minimized');
            
            if (panel.classList.contains('minimized')) {
                // Store current dimensions before minimizing
                panel.dataset.savedWidth = panel.style.width || '800px';
                panel.dataset.savedHeight = panel.style.height || '600px';
                // Force minimal height when minimized
                panel.style.width = 'auto';
                panel.style.height = 'auto';
                panel.style.minHeight = '0';
                panel.style.minWidth = '0';
                panel.style.bottom = ''; // Clear bottom anchor to prevent stretching
                btn.textContent = '+';
            } else {
                // Restore previous dimensions when expanding
                panel.style.width = panel.dataset.savedWidth || '800px';
                panel.style.height = panel.dataset.savedHeight || '600px';
                panel.style.minHeight = '';
                panel.style.minWidth = '';
                btn.textContent = '‚àí';
            }
        });
        
        // Tab switching for traces
        document.querySelectorAll('.trace-tab-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const tabName = btn.getAttribute('data-tab');
                
                // Update button states
                document.querySelectorAll('.trace-tab-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                // Update tab content visibility
                document.querySelectorAll('.trace-tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                document.getElementById(tabName + '-tab').classList.add('active');
                
                // Force chart resize when switching tabs
                setTimeout(() => {
                    if (tabName === 'thrust' && typeof liftChart !== 'undefined') {
                        liftChart.resize();
                    } else if (tabName === 'moment-y' && typeof momentYChart !== 'undefined') {
                        momentYChart.resize();
                    } else if (tabName === 'moment-z' && typeof momentZChart !== 'undefined') {
                        momentZChart.resize();
                    }
                }, 100);
            });
        });
        
        // Spanwise panel tab switching
        document.querySelectorAll('.spanwise-tab-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const tabName = btn.getAttribute('data-tab');
                
                // Update button states
                document.querySelectorAll('.spanwise-tab-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                // Update tab content visibility
                document.querySelectorAll('.spanwise-tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                document.getElementById(tabName + '-tab').classList.add('active');
                
                // Force chart resize when switching tabs
                setTimeout(() => {
                    if (tabName === 'loading' && typeof spanwiseChart !== 'undefined') {
                        spanwiseChart.resize();
                    } else if (tabName === 'section') {
                        updateSectionDiagram();
                    }
                }, 100);
            });
        });
        
        // Spanwise panel minimize/maximize
        document.getElementById('minimize-spanwise-btn').addEventListener('click', function() {
            const panel = document.getElementById('spanwise-panel');
            const btn = this;
            
            if (panel.classList.contains('minimized')) {
                // Expand
                panel.classList.remove('minimized');
                btn.textContent = '‚àí';
            } else {
                // Minimize - clear inline styles first
                panel.style.width = '';
                panel.style.height = '';
                panel.classList.add('minimized');
                btn.textContent = '+';
            }
        });
        
        // Window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            if (composer){
                composer.setSize(window.innerWidth, window.innerHeight);
                if (fxaaPass){
                    fxaaPass.material.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight);
                }
            }
        });
        
        // Animation loop
        let lastFrameTime = 0;
        const targetFrameTime = 1000 / 60; // 60 FPS target
        
        function animate(currentTime) {
            requestAnimationFrame(animate);
            
            // Frame rate limiter - only update if enough time has passed
            if (currentTime - lastFrameTime < targetFrameTime * 0.9) {
                // Still render, just don't update physics
                renderer.render(scene, camera);
                return;
            }
            lastFrameTime = currentTime;
            
            // Increment frame counter
            frameCount++;
            
            // Update blade loads BEFORE rotating (so loads match current position)
            updateBladeLoads();
            
            // Rotate rotor AFTER calculating loads (only if not paused)
            if (!turbineParams.paused) {
                // Apply speed multiplier during fast Fourier collection
                const speedMultiplier = (fourierData.collecting && fourierData.fastMode) ? fourierData.speedMultiplier : 1;
                const deltaRotation = (turbineParams.shaftSpeed * 2 * Math.PI) / (60 * 60) * speedMultiplier; // per frame at 60fps
                rotorGroup.rotation.x += deltaRotation;
                
                // Rotate wind farm turbines with speed variation
                additionalTurbines.forEach(turbine => {
                    const rotorGrp = turbine.userData.rotorGroup;
                    const speedMult = turbine.userData.speedMultiplier;
                    if (rotorGrp) {
                        rotorGrp.rotation.x += deltaRotation * speedMult * speedMultiplier;
                    }
                });
            }
            
            // Keep sky centered on camera for infinite distance effect
            skyboxMesh.position.copy(camera.position);
            
            // Animate cloud layer
            cloudOffset += 0.0002;
            cloudPlane.material.map.offset.set(cloudOffset, cloudOffset * 0.7);
            cloudPlane.position.x = camera.position.x;
            cloudPlane.position.z = camera.position.z;
            
            controls.update();
            renderer.render(scene, camera);
        }
        
        // Optional cinematic zoom on key 'z'
        function ease(t){ return t<.5 ? 2*t*t : -1+(4-2*t)*t; }
        function cinematicZoom(targetPos, lookAt, duration=1200){
            const start = performance.now();
            const startPos = camera.position.clone();
            const startExp = renderer.toneMappingExposure;
            const startFocus = bokehPass ? bokehPass.materialBokeh.uniforms['focus'].value : PhotoConfig.bokehFocusFar;
            const endFocus = PhotoConfig.bokehFocusNear;
            const endExp = 1.25;

            function step(now){
                const t = Math.min(1, (now-start)/duration), k = ease(t);
                camera.position.lerpVectors(startPos, targetPos, k);
                controls.target.lerp(lookAt, k);
                if (isPhotoMode){
                    renderer.toneMappingExposure = THREE.MathUtils.lerp(startExp, endExp, k);
                    if (bokehPass) bokehPass.materialBokeh.uniforms['focus'].value =
                        THREE.MathUtils.lerp(startFocus, endFocus, k);
                }
                if (t<1) requestAnimationFrame(step);
            }
            requestAnimationFrame(step);
        }
        document.addEventListener('keydown', (e)=>{
            if (e.key==='z' && hub){
                const p = new THREE.Vector3(); hub.getWorldPosition(p);
                cinematicZoom(p.clone().add(new THREE.Vector3(6,2,6)), p);
            }
        });
        
        // Display toggle button
        let displayState = {
            modalsHidden: false,
            savedVisibility: {}
        };
        
        document.getElementById('display-toggle').addEventListener('click', () => {
            const btn = document.getElementById('display-toggle');
            const panels = ['controls-panel', 'stats', 'legend', 'plot-panel', 'spanwise-panel'];
            
            if (!displayState.modalsHidden) {
                // Hide all modals
                panels.forEach(id => {
                    const panel = document.getElementById(id);
                    displayState.savedVisibility[id] = panel.style.display || 'block';
                    panel.style.display = 'none';
                });
                btn.textContent = 'üì∫ Show Displays';
                displayState.modalsHidden = true;
            } else {
                // Restore modals
                panels.forEach(id => {
                    const panel = document.getElementById(id);
                    panel.style.display = displayState.savedVisibility[id] || 'block';
                });
                btn.textContent = 'üì∫ Hide Displays';
                displayState.modalsHidden = false;
            }
        });
        
        animate();
    </script>


</body></html>
