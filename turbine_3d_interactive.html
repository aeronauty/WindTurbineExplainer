<!DOCTYPE html>
<html lang="en"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Wind Turbine 3D</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }
        #controls-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            max-width: 350px;
            max-height: 90vh;
            overflow-y: auto;
        }
        #controls-panel.minimized #controls-content {
            display: none;
        }
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #667eea;
        }
        h2 {
            color: #333;
            font-size: 1.5em;
            margin: 0;
        }
        .minimize-btn {
            background: #667eea;
            color: white;
            border: none;
            border-radius: 4px;
            width: 30px;
            height: 30px;
            cursor: pointer;
            font-size: 1.2em;
            line-height: 1;
        }
        .minimize-btn:hover {
            background: #5568d3;
        }
        .control-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            color: #555;
            font-weight: 500;
        }
        input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }
        .value-display {
            display: inline-block;
            min-width: 50px;
            text-align: right;
            font-weight: bold;
            color: #667eea;
        }
        .info-text {
            font-size: 0.85em;
            color: #777;
            margin-top: 3px;
        }
        #stats {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            min-width: 200px;
        }
        #stats h3 {
            margin-bottom: 10px;
            color: #333;
            font-size: 1.2em;
        }
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid #eee;
        }
        .stat-row:last-child {
            border-bottom: none;
        }
        .stat-label {
            color: #666;
        }
        .stat-value {
            font-weight: bold;
            color: #667eea;
        }
        #legend {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        #legend h3 {
            margin-bottom: 10px;
            color: #333;
            font-size: 1.1em;
        }
        .legend-gradient {
            height: 30px;
            background: linear-gradient(to right, 
                #0000ff, #0080ff, #00ffff, #00ff00, 
                #ffff00, #ff8000, #ff0000, #8b0000);
            border-radius: 5px;
            margin-bottom: 8px;
        }
        .legend-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.85em;
            color: #666;
        }
        #plot-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            width: 800px;
            height: 600px;
            resize: both;
            overflow: auto;
            min-width: 400px;
            min-height: 300px;
        }
        #plot-panel.minimized {
            height: auto;
            resize: none;
        }
        #plot-panel.minimized #plot-content {
            display: none;
        }
        .plot-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #667eea;
        }
        .plot-title {
            color: #333;
            font-size: 1.2em;
            font-weight: bold;
        }
        .plot-controls {
            margin-bottom: 15px;
        }
        .trace-tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
            border-bottom: 2px solid #ddd;
        }
        .trace-tab-btn {
            padding: 8px 16px;
            background: none;
            border: none;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            font-size: 0.95em;
            color: #666;
            transition: all 0.2s;
        }
        .trace-tab-btn:hover {
            color: #333;
            background: rgba(102, 126, 234, 0.1);
        }
        .trace-tab-btn.active {
            color: #667eea;
            border-bottom-color: #667eea;
            font-weight: bold;
        }
        .trace-tab-content {
            display: none;
            height: calc(100% - 120px);
            overflow-y: auto;
        }
        .trace-tab-content.active {
            display: block;
        }
        .chart-container {
            margin-bottom: 20px;
            height: 300px;
        }
        .chart-with-fourier {
            display: flex;
            flex-direction: column;
            gap: 15px;
            height: 100%;
        }
        .chart-with-fourier .chart-container {
            flex: 1;
            min-height: 250px;
        }
        .fourier-summary {
            background: #f9f9f9;
            padding: 15px;
            border-radius: 8px;
            max-height: 300px;
            overflow-y: auto;
        }
        input[type="checkbox"] {
            margin-right: 5px;
        }
        select {
            width: 100%;
            padding: 5px;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="controls-panel">
        <div class="panel-header">
            <h2>üå¨Ô∏è Wind Turbine Controls</h2>
            <button class="minimize-btn" id="minimize-btn">+</button>
        </div>
        <div id="controls-content">
            <div class="control-group">
                <label>Wind Speed: <span class="value-display" id="wind-speed-value">10.0</span> m/s</label>
                <input type="range" id="wind-speed" min="0" max="25" value="10" step="0.5">
            </div>
            
            <div class="control-group">
                <label>Shaft Speed: <span class="value-display" id="shaft-speed-value">10.0</span> RPM</label>
                <input type="range" id="shaft-speed" min="0" max="20" value="10" step="0.5">
            </div>
            
            <div class="control-group">
                <label>
                    <input type="checkbox" id="pause-rotation"> Pause Rotation
                </label>
            </div>
            
            <div class="control-group">
                <label>Manual Rotation: <span class="value-display" id="manual-rotation-value">0.0</span>¬∞</label>
                <input type="range" id="manual-rotation" min="0" max="360" value="0" step="0.1">
                <div class="info-text">Manual rotor angle control (when paused)</div>
            </div>
            
            <div class="control-group">
                <label>Blade Pitch: <span class="value-display" id="blade-pitch-value">0.0</span>¬∞</label>
                <input type="range" id="blade-pitch" min="-10" max="30" value="0" step="1">
                <div class="info-text">Visual pitch angle</div>
            </div>
            
            <div class="control-group">
                <label>Number of Blades: <span class="value-display" id="num-blades-value">3</span></label>
                <input type="range" id="num-blades" min="1" max="20" value="3" step="1">
            </div>
            
            <div class="control-group">
                <label>Yaw Angle: <span class="value-display" id="yaw-value">0.0</span>¬∞</label>
                <input type="range" id="yaw" min="-30" max="30" value="0" step="1">
                <div class="info-text">Nacelle yaw misalignment</div>
            </div>
            
            <div class="control-group">
                <label>Inflow Angle: <span class="value-display" id="inflow-value">0.0</span>¬∞</label>
                <input type="range" id="inflow" min="-20" max="20" value="0" step="1">
                <div class="info-text">Vertical wind component</div>
            </div>
            
            <div class="control-group">
                <label>
                    <input type="checkbox" id="show-axes"> Show Axes (RGB = XYZ)
                </label>
                <div class="info-text">Red=X, Green=Y, Blue=Z</div>
            </div>
            
            <div class="control-group">
                <label>
                    <input type="checkbox" id="photo-mode"> Photo Rendering
                </label>
                <div class="info-text">HDRI + PBR + bloom/DOF (slower)</div>
            </div>
            
            <div class="control-group">
                <label>
                    <input type="checkbox" id="show-heatmap" checked=""> Show Load Heatmap
                </label>
                <div class="info-text">Color-coded blade loads</div>
            </div>
            
            <div class="control-group">
                <label>
                    <input type="checkbox" id="show-vectors"> Show Force Vectors
                </label>
            </div>
            
            <div class="control-group">
                <label>Vector Scale: <span class="value-display" id="vector-scale-value">0.100</span></label>
                <input type="range" id="vector-scale" min="0.001" max="1.0" value="0.1" step="0.001">
            </div>
            
            <div class="control-group">
                <label>Vector Display:</label>
                <select id="vector-mode">
                    <option value="all">All Blades</option>
                    <option value="single">Single Blade</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>Angular Resolution: <span class="value-display" id="angular-res-value">1.0</span>¬∞</label>
                <input type="range" id="angular-resolution" min="0.333" max="15" value="1" step="0.01">
                <div class="info-text">Sampling resolution (lower = more detail)</div>
            </div>
        </div>
    </div>
    
    <div id="stats">
        <h3>üìä Statistics</h3>
        <div class="stat-row">
            <span class="stat-label">Max Load:</span>
            <span class="stat-value" id="max-load">73.14</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Avg AoA:</span>
            <span class="stat-value" id="avg-aoa">44.5</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Tip Speed:</span>
            <span class="stat-value" id="tip-speed">20.9</span>
        </div>
    </div>
    
    <div id="legend">
        <h3>Load Scale</h3>
        <div class="legend-gradient"></div>
        <div class="legend-labels">
            <span>Low</span>
            <span>High</span>
        </div>
    </div>
    
    <div id="plot-panel">
        <div class="plot-header">
            <div class="plot-title">üìä Load Traces</div>
            <button class="minimize-btn" id="minimize-plot-btn">+</button>
        </div>
        <div id="plot-content">
            <div class="plot-controls">
                <label>Radial Station (% span): <span class="value-display" id="station-value">50</span></label>
                <input type="range" id="radial-station" min="10" max="95" value="50" step="5">
            </div>
            
            <div class="trace-tabs">
                <button class="trace-tab-btn active" data-tab="thrust">Thrust</button>
                <button class="trace-tab-btn" data-tab="moment-y">Yawing Moment (M_y)</button>
                <button class="trace-tab-btn" data-tab="moment-z">Nodding Moment (M_z)</button>
                <button class="trace-tab-btn" data-tab="debug">Debug</button>
            </div>
            
            <div id="thrust-tab" class="trace-tab-content active">
                <div class="chart-with-fourier">
                    <div class="chart-container">
                        <canvas id="lift-chart"></canvas>
                    </div>
                    <div class="fourier-summary">
                        <h4 style="margin-top: 0; font-size: 1em;">Thrust Harmonics</h4>
                        <div id="fourier-thrust-content"></div>
                    </div>
                </div>
            </div>
            
            <div id="moment-y-tab" class="trace-tab-content">
                <div class="chart-with-fourier">
                    <div class="chart-container">
                        <canvas id="moment-y-chart"></canvas>
                    </div>
                    <div class="fourier-summary">
                        <h4 style="margin-top: 0; font-size: 1em;">Yawing Moment Harmonics</h4>
                        <div id="fourier-moment-y-content"></div>
                    </div>
                </div>
            </div>
            
            <div id="moment-z-tab" class="trace-tab-content">
                <div class="chart-with-fourier">
                    <div class="chart-container">
                        <canvas id="moment-z-chart"></canvas>
                    </div>
                    <div class="fourier-summary">
                        <h4 style="margin-top: 0; font-size: 1em;">Nodding Moment Harmonics</h4>
                        <div id="fourier-moment-z-content"></div>
                    </div>
                </div>
            </div>
            
            <div id="debug-tab" class="trace-tab-content">
                <button id="generate-debug" style="margin-bottom: 10px; padding: 8px 16px; background: #667eea; color: white; border: none; border-radius: 4px; cursor: pointer;">Generate Debug Data (2 Blades, 2 Revolutions)</button>
                <div id="debug-output" style="font-family: monospace; font-size: 0.85em;"></div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
    
    <!-- Photo Rendering Mode Dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/RGBELoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/pmrem/PMREMGenerator.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/BokehPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/FXAAShader.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        scene.fog = new THREE.Fog(0x87ceeb, 50, 200);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(50, 30, 50);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // ready for photo mode
        document.getElementById('canvas-container').appendChild(renderer.domElement);
        
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(50, 50, 50);
        directionalLight.castShadow = true;
        scene.add(directionalLight);
        
        // Ground
        const groundGeometry = new THREE.PlaneGeometry(200, 200);
        const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x4a7c59 });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);
        
        // Debug axes
        const sceneAxes = new THREE.AxesHelper(30);
        sceneAxes.visible = false;
        scene.add(sceneAxes);
        
        const rotorAxes = new THREE.AxesHelper(25);
        rotorAxes.visible = false;
        
        const nacelleAxes = new THREE.AxesHelper(5);
        nacelleAxes.visible = false;
        
        // --- Photo mode config/state ---
        const PhotoConfig = {
            HDRI_URL: "https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/2k/kloppenheim_06_2k.hdr",
            bloomStrength: 0.35,
            bloomRadius: 0.8,
            bloomThreshold: 0.85,
            bokehFocusNear: 15,
            bokehFocusFar: 80,
            bokehAperture: 0.00001,   // Minimal blur
            bokehMaxBlur: 0.0005,     // Almost no blur
            useBokeh: false,          // Disable bokeh by default
        };
        
        let isPhotoMode = false;
        let composer = null, renderPass = null, bloomPass = null, bokehPass = null, fxaaPass = null;
        let pmremGen = null, envMap = null;
        let skyboxMesh = null;  // For scalable background
        
        // remember "simple" look to restore
        const OriginalLook = {
            background: scene.background ? scene.background.clone() : null,
            fog: scene.fog || null,
            dirLightIntensity: directionalLight.intensity,
        };
        
        // cache original materials to restore later
        const OriginalMats = new Map(); // mesh => material
        function cacheMaterial(mesh){
            if (!OriginalMats.has(mesh)) OriginalMats.set(mesh, mesh.material);
        }
        
        // Turbine parameters
        const turbineParams = {
            windSpeed: 10,
            shaftSpeed: 10,
            bladePitch: 0,
            numBlades: 3,
            yawAngle: 0,
            inflowAngle: 0,
            towerHeight: 30,
            bladeRadius: 20,
            hubRadius: 1.5,
            radialStation: 0.5,  // 0 to 1 (fraction of span)
            showVectors: false,  // Show force vectors
            vectorScale: 0.1,    // Force vector scale factor
            vectorMode: 'all',   // 'all' or 'single' blade
            showHeatmap: true,   // Show load heatmap on blades
            angularResolution: 1.0,  // Angular resolution in degrees (0.333 to 15)
            paused: false,       // Pause rotation
            manualRotation: 0    // Manual rotation angle in degrees
        };
        
        // Data history for plotting
        // After fast Fourier, traces will scroll continuously
        const plotData = {
            time: [],           // Now represents continuous time, not azimuth
            bladeLift: [],
            bladeMomentY: [],
            bladeMomentZ: [],
            totalLift: [],
            totalMomentY: [],
            totalMomentZ: [],
            timeValue: 0,       // Continuous time counter (in radians)
            tdcMarkers: []      // Track when blade 1 hits top dead center (azimuth = 0)
        };
        
        // Fourier analysis data collection
        const fourierData = {
            collecting: false,
            startAzimuth: 0,
            bladeLift: [],
            bladeMomentY: [],
            bladeMomentZ: [],
            totalLift: [],
            totalMomentY: [],
            totalMomentZ: [],
            complete: false,
            fastMode: false,  // Use fast collection for first revolution
            lastCollectionTime: 0,
            samplingInterval: 0,
            speedMultiplier: 5  // Speed up rotation by this factor during fast collection
        };
        
        let timeCounter = 0;
        
        function initPlotData() {
            plotData.time = [];
            plotData.bladeLift = [];
            plotData.bladeMomentY = [];
            plotData.bladeMomentZ = [];
            plotData.totalLift = [];
            plotData.totalMomentY = [];
            plotData.totalMomentZ = [];
            plotData.timeValue = 0;
            plotData.tdcMarkers = [];
            for (let i = 0; i < turbineParams.numBlades; i++) {
                plotData.bladeLift[i] = [];
                plotData.bladeMomentY[i] = [];
                plotData.bladeMomentZ[i] = [];
            }
            timeCounter = 0;
        }
        
        initPlotData();
        
        // Reset Fourier analysis collection
        function resetFourierCollection() {
            fourierData.collecting = false;
            fourierData.complete = false;
            fourierData.bladeLift = [];
            fourierData.bladeMomentY = [];
            fourierData.bladeMomentZ = [];
            fourierData.totalLift = [];
            fourierData.totalMomentY = [];
            fourierData.totalMomentZ = [];
            fourierData.fastMode = true; // Next collection will be fast
        }
        
        // Start Fourier collection at current azimuth
        function startFourierCollection() {
            const currentAzimuthRad = rotorGroup.rotation.x;
            fourierData.startAzimuth = currentAzimuthRad;
            fourierData.collecting = true;
            fourierData.complete = false;
            fourierData.bladeLift = [];
            fourierData.bladeMomentY = [];
            fourierData.bladeMomentZ = [];
            fourierData.totalLift = [];
            fourierData.totalMomentY = [];
            fourierData.totalMomentZ = [];
            
            // Set sampling interval based on mode
            if (fourierData.fastMode) {
                // Fast mode: collect ~36-72 points per revolution (5-10 degree steps)
                fourierData.samplingInterval = Math.max(5, turbineParams.angularResolution);
            } else {
                // Normal mode: use current angular resolution
                fourierData.samplingInterval = turbineParams.angularResolution;
            }
            
            fourierData.lastCollectionTime = 0;
        }
        
        // Tower
        const towerGeometry = new THREE.CylinderGeometry(0.8, 1.2, turbineParams.towerHeight, 16);
        const towerMaterial = new THREE.MeshPhongMaterial({ color: 0xcccccc });
        const tower = new THREE.Mesh(towerGeometry, towerMaterial);
        tower.position.y = turbineParams.towerHeight / 2;
        tower.castShadow = true;
        scene.add(tower);
        
        // Nacelle (rotates for yaw)
        const nacelleGroup = new THREE.Group();
        nacelleGroup.position.set(0, turbineParams.towerHeight, 0);
        scene.add(nacelleGroup);
        
        const nacelleGeometry = new THREE.BoxGeometry(4, 2, 2);
        const nacelleMaterial = new THREE.MeshPhongMaterial({ color: 0xeeeeee });
        const nacelle = new THREE.Mesh(nacelleGeometry, nacelleMaterial);
        nacelle.castShadow = true;
        nacelleGroup.add(nacelle);
        nacelleGroup.add(nacelleAxes);
        
        // Rotor group (contains hub and blades, rotates about X-axis)
        const rotorGroup = new THREE.Group();
        rotorGroup.position.x = 2;
        nacelleGroup.add(rotorGroup);
        rotorGroup.add(rotorAxes);
        
        // Hub
        const hubGeometry = new THREE.SphereGeometry(turbineParams.hubRadius, 16, 16);
        const hubMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
        const hub = new THREE.Mesh(hubGeometry, hubMaterial);
        hub.castShadow = true;
        rotorGroup.add(hub);
        
        // Cache initial materials for photo mode toggle
        cacheMaterial(tower);
        cacheMaterial(nacelle);
        cacheMaterial(hub);
        cacheMaterial(ground);
        
        // Blades
        const blades = [];
        const bladeSegments = [];
        let forceArrows = [];
        
        // Helper to iterate all meshes for photo mode
        function forEachMesh(fn){
            fn(tower); fn(nacelle); fn(hub); fn(ground);
            bladeSegments.forEach(fn);
        }
        
        function createBlade() {
            const bladeGroup = new THREE.Group();
            
            // Pitch group for visual blade pitch
            const pitchGroup = new THREE.Group();
            bladeGroup.add(pitchGroup);
            
            const numSegments = 100;
            const segments = [];
            
            for (let i = 0; i < numSegments; i++) {
                const r = turbineParams.hubRadius + (i / numSegments) * (turbineParams.bladeRadius - turbineParams.hubRadius);
                const nextR = turbineParams.hubRadius + ((i + 1) / numSegments) * (turbineParams.bladeRadius - turbineParams.hubRadius);
                const segmentLength = nextR - r;
                
                const chord = 1.5 * (1 - i / numSegments) + 0.3;
                
                const segmentGeometry = new THREE.BoxGeometry(0.2, segmentLength, chord);
                const segmentMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x4444ff,
                    shininess: 30,
                    specular: 0x222222
                });
                const segment = new THREE.Mesh(segmentGeometry, segmentMaterial);
                
                segment.position.y = r + segmentLength / 2;
                segment.castShadow = true;
                
                segment.userData.radius = r + segmentLength / 2;
                segment.userData.chord = chord;
                
                pitchGroup.add(segment);
                segments.push(segment);
                bladeSegments.push(segment);
                cacheMaterial(segment); // Cache for photo mode
            }
            
            bladeGroup.segments = segments;
            bladeGroup.pitchGroup = pitchGroup;
            
            // Rotate blade to extend radially
            bladeGroup.rotation.y = Math.PI / 2;
            
            return bladeGroup;
        }
        
        function updateBladeCount() {
            blades.forEach(blade => rotorGroup.remove(blade));
            blades.length = 0;
            bladeSegments.length = 0;
            
            for (let i = 0; i < turbineParams.numBlades; i++) {
                const blade = createBlade();
                blade.rotation.x = (i * 2 * Math.PI) / turbineParams.numBlades;
                rotorGroup.add(blade);
                blades.push(blade);
            }
            
            // Reset plot data when blade count changes
            initPlotData();
            if (typeof liftChart !== 'undefined') {
                rebuildCharts();
            }
            resetFourierCollection();
        }
        
        // Color mapping function (enhanced with more stops)
        function getLoadColor(normalizedLoad) {
            const colors = [
                { pos: 0.0, color: new THREE.Color(0x0000ff) },   // Blue
                { pos: 0.14, color: new THREE.Color(0x0080ff) },  // Light blue
                { pos: 0.28, color: new THREE.Color(0x00ffff) },  // Cyan
                { pos: 0.42, color: new THREE.Color(0x00ff00) },  // Green
                { pos: 0.57, color: new THREE.Color(0xffff00) },  // Yellow
                { pos: 0.71, color: new THREE.Color(0xff8000) },  // Orange
                { pos: 0.85, color: new THREE.Color(0xff0000) },  // Red
                { pos: 1.0, color: new THREE.Color(0x8b0000) }    // Dark red
            ];
            
            for (let i = 0; i < colors.length - 1; i++) {
                if (normalizedLoad >= colors[i].pos && normalizedLoad <= colors[i + 1].pos) {
                    const t = (normalizedLoad - colors[i].pos) / (colors[i + 1].pos - colors[i].pos);
                    return new THREE.Color().lerpColors(colors[i].color, colors[i + 1].color, t);
                }
            }
            return colors[colors.length - 1].color;
        }
        
        // Update blade loads
        function updateBladeLoads() {
            const omega = turbineParams.shaftSpeed * 2 * Math.PI / 60;
            const windSpeed = turbineParams.windSpeed;
            const yawRadians = turbineParams.yawAngle * Math.PI / 180;
            const inflowRadians = turbineParams.inflowAngle * Math.PI / 180;
            
            // Wind speed components due to yaw
            const windSpeedAxial = windSpeed * Math.cos(yawRadians);
            const windSpeedTangential = windSpeed * Math.sin(yawRadians);
            
            let maxLoad = -Infinity;
            let minLoad = Infinity;
            let totalAoA = 0;
            let aoaCount = 0;
            
            blades.forEach((blade, bladeIndex) => {
                // Calculate azimuth from blade's actual rotation in the rotor
                // blade.rotation.x is the blade's offset, rotorGroup.rotation.x is the current rotor angle
                const azimuth = rotorGroup.rotation.x + blade.rotation.x;
                
                // Store azimuth at blade level for consistent data collection
                blade.userData.currentAzimuth = azimuth;
                
                blade.segments.forEach((segment, segIdx) => {
                    const r = segment.userData.radius;
                    const chord = segment.userData.chord;
                    
                    // Blade twist distribution (typical for wind turbine)
                    // Higher twist at root (low speed), lower at tip (high speed)
                    // Range: ~14¬∞ at root to ~0¬∞ at tip
                    const r_norm = (r - turbineParams.hubRadius) / (turbineParams.bladeRadius - turbineParams.hubRadius);
                    const twist = 14 * (1 - r_norm); // Linear twist from 14¬∞ at root to 0¬∞ at tip
                    
                    // Velocities in rotor disc coordinates
                    // alpha = angle of attack (inflow), beta = sideslip (yaw)
                    // Disc velocity components:
                    // x = V sin(beta) - horizontal in-plane
                    // y = V sin(alpha) cos(beta) - vertical in-plane  
                    // z = V cos(alpha) cos(beta) - axial (thrust direction)
                    
                    const V = turbineParams.windSpeed;
                    const alpha = inflowRadians;
                    const beta = yawRadians;
                    
                    const V_x = V * Math.sin(beta);
                    const V_y = V * Math.sin(alpha) * Math.cos(beta);
                    const V_z = V * Math.cos(alpha) * Math.cos(beta);
                    
                    // In-plane velocity component at blade azimuth (perpendicular to radius)
                    // This adds to tangential velocity
                    const V_inplane_tangential = V_x * Math.cos(azimuth) - V_y * Math.sin(azimuth);
                    
                    // Tangential velocity (rotation + in-plane wind)
                    const Vt = omega * r + V_inplane_tangential;
                    
                    // Normal velocity (axial wind + induction)
                    const Vn = -V_z * (1 - 0.3); // With induction factor
                    
                    // Flow angle and angle of attack
                    const phi = Math.atan2(Vn, Vt);
                    const aoa = -(phi * 180 / Math.PI - twist + turbineParams.bladePitch);
                    
                    totalAoA += aoa;
                    aoaCount++;
                    
                    // Dynamic pressure
                    const V_total = Math.sqrt(Vt * Vt + Vn * Vn);
                    const q = 0.5 * 1.225 * V_total * V_total * chord * (turbineParams.bladeRadius / 100);
                    
                    // Simple aerodynamic model
                    // Lift: 2œÄ lift slope (thin airfoil theory)
                    // Drag: constant 5% of lift magnitude
                    const Cl = 2 * Math.PI * Math.sin(aoa * Math.PI / 180);
                    const L = q * Cl;
                    const D = 0.05 * Math.abs(L);
                    
                    // Thrust (axial force)
                    const thrust = L * Math.cos(phi) + D * Math.sin(phi);
                    
                    // Store values (including azimuth for consistent plotting)
                    const load = Math.abs(thrust);
                    segment.userData.load = load;
                    segment.userData.aoa = aoa;
                    segment.userData.azimuth = azimuth;
                    segment.userData.thrust = thrust;
                    segment.userData.L = L;  // Store lift for resultant vector
                    segment.userData.D = D;  // Store drag for resultant vector
                    segment.userData.phi = phi;  // Store flow angle for resultant vector
                    
                    if (load > maxLoad) maxLoad = load;
                    if (load < minLoad) minLoad = load;
                });
            });
            
            // Update force vectors visualization - show as load distribution
            if (turbineParams.showVectors) {
                forceArrows.forEach(arrow => scene.remove(arrow));
                forceArrows = [];
                
                blades.forEach((blade, bladeIndex) => {
                    // Skip blades if single blade mode
                    if (turbineParams.vectorMode === 'single' && bladeIndex !== 0) return;
                    
                    const points = [];
                    const basePoints = [];
                    
                    // Collect points for load distribution curve
                    blade.segments.forEach((segment, segIdx) => {
                        const L = segment.userData.L || 0;
                        const D = segment.userData.D || 0;
                        const phi = segment.userData.phi || 0;
                        
                        // Get segment world position (base of vector)
                        const worldPos = new THREE.Vector3();
                        segment.getWorldPosition(worldPos);
                        basePoints.push(worldPos.clone());
                        
                        // Resultant force in blade section coordinates:
                        // Lift is perpendicular to relative velocity (rotated by phi from tangent)
                        // Drag is parallel to relative velocity
                        // 
                        // In blade section frame (tangent/normal to blade):
                        // - Tangent direction is along blade motion (perpendicular to radius)
                        // - Normal direction is toward leading edge
                        //
                        // Force components in section frame:
                        // F_tangent = L * sin(phi) - D * cos(phi)  (tangential force, creates torque)
                        // F_normal = L * cos(phi) + D * sin(phi)   (normal force, creates thrust)
                        
                        const F_tangent = L * Math.sin(phi) - D * Math.cos(phi);
                        const F_normal = L * Math.cos(phi) + D * Math.sin(phi);
                        
                        // Get the tangent direction (blade motion direction, perpendicular to radius)
                        // In the blade's local frame, tangent is along +Z (spanwise cross radial)
                        const tangentDir = new THREE.Vector3(0, 0, 1);
                        tangentDir.applyQuaternion(segment.getWorldQuaternion(new THREE.Quaternion()));
                        
                        // Normal direction is toward leading edge (along +X in blade frame)
                        const normalDir = new THREE.Vector3(1, 0, 0);
                        normalDir.applyQuaternion(segment.getWorldQuaternion(new THREE.Quaternion()));
                        
                        // Resultant force vector
                        const forceVec = normalDir.multiplyScalar(F_normal).add(
                            tangentDir.multiplyScalar(F_tangent)
                        );
                        
                        // Scale vector by scale factor
                        const vectorLength = turbineParams.vectorScale;
                        const tipPos = worldPos.clone().add(forceVec.multiplyScalar(vectorLength));
                        points.push(tipPos);
                    });
                    
                    // Create lines from base to tip for each segment
                    for (let i = 0; i < points.length; i++) {
                        const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                            basePoints[i],
                            points[i]
                        ]);
                        const lineMaterial = new THREE.LineBasicMaterial({ 
                            color: 0xff0000,
                            linewidth: 1,
                            transparent: true,
                            opacity: 0.6
                        });
                        const line = new THREE.Line(lineGeometry, lineMaterial);
                        scene.add(line);
                        forceArrows.push(line);
                    }
                    
                    // Create curve connecting all tips (load distribution envelope)
                    if (points.length > 1) {
                        const curveGeometry = new THREE.BufferGeometry().setFromPoints(points);
                        const curveMaterial = new THREE.LineBasicMaterial({ 
                            color: 0xff0000,
                            linewidth: 2
                        });
                        const curve = new THREE.Line(curveGeometry, curveMaterial);
                        scene.add(curve);
                        forceArrows.push(curve);
                    }
                });
            } else {
                // Hide vectors if disabled
                forceArrows.forEach(arrow => scene.remove(arrow));
                forceArrows = [];
            }
            
            // Autoscale and color segments
            const loadRange = maxLoad - minLoad;
            bladeSegments.forEach(segment => {
                if (turbineParams.showHeatmap) {
                    const normalizedLoad = loadRange > 0 ? (segment.userData.load - minLoad) / loadRange : 0;
                    const color = getLoadColor(normalizedLoad);
                    if (isPhotoMode){
                        // tint base color slightly + glow with emissive
                        segment.material.color.lerp(color, 0.35);
                        if (segment.material.emissive) {
                            segment.material.emissive.lerp(color, 0.6);
                        }
                    } else {
                        segment.material.color = color.clone ? color.clone() : color;
                    }
                } else {
                    // Reset to neutral color when heatmap is off
                    const neutralColor = new THREE.Color(0xcccccc);
                    if (isPhotoMode && segment.material.emissive) {
                        segment.material.color.copy(neutralColor);
                        segment.material.emissive.set(0x000000);
                    } else {
                        segment.material.color.copy(neutralColor);
                    }
                }
            });
            
            // Update stats (dimensionless)
            document.getElementById('max-load').textContent = maxLoad.toFixed(2);
            document.getElementById('avg-aoa').textContent = (totalAoA / aoaCount).toFixed(1);
            const tipSpeed = (turbineParams.shaftSpeed * 2 * Math.PI / 60) * turbineParams.bladeRadius;
            document.getElementById('tip-speed').textContent = tipSpeed.toFixed(1);
            
            // Update plot data
            if (omega > 0) {
                timeCounter++;
                
                // Calculate update interval based on angular resolution
                // angularResolution is in degrees, we need to convert to radians and calculate frames
                const degreesPerFrame = (turbineParams.shaftSpeed * 360) / (60 * 60); // degrees per frame at 60fps
                const framesPerSample = turbineParams.angularResolution / degreesPerFrame;
                const updateInterval = Math.max(1, Math.round(framesPerSample));
                
                // Only update plot data when not paused
                if (timeCounter % updateInterval === 0 && !turbineParams.paused) {
                    updatePlotData(omega);
                }
            }
        }
        
        // Photo Mode Enable/Disable Functions
        function enablePhotoMode(){
            if (isPhotoMode) return;
            isPhotoMode = true;

            // Renderer: physically-correct pipeline
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2; // Brighter for outdoor scene
            renderer.physicallyCorrectLights = true;

            // Enhanced lighting for photorealism
            // 1. Warm sunlight (5500K color temperature)
            directionalLight.color.setHex(0xffffee);
            directionalLight.intensity = 3.5;
            directionalLight.position.set(100, 80, 100); // More dramatic angle
            
            // 2. Enhanced shadow system (4096x4096 for crisp shadows)
            directionalLight.shadow.mapSize.set(4096, 4096);
            directionalLight.shadow.camera.left = -150;
            directionalLight.shadow.camera.right = 150;
            directionalLight.shadow.camera.top = 150;
            directionalLight.shadow.camera.bottom = -150;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 500;
            directionalLight.shadow.bias = -0.0001; // Prevent shadow acne
            directionalLight.shadow.radius = 2; // Softer shadow edges
            
            // 3. Hemisphere light for natural sky/ground bounce
            const hemiLight = new THREE.HemisphereLight(
                0x87ceeb,  // Sky color (light blue)
                0x4a7c2f,  // Ground color (grass green)
                0.6        // Intensity
            );
            hemiLight.position.set(0, 50, 0);
            scene.add(hemiLight);
            hemiLight.userData.isPhotoModeLight = true;
            
            // 4. Subtle rim light from opposite side
            const rimLight = new THREE.DirectionalLight(0xccddff, 0.3);
            rimLight.position.set(-80, 40, -80);
            scene.add(rimLight);
            rimLight.userData.isPhotoModeLight = true;
            
            // 5. Atmospheric fog for depth
            scene.fog = new THREE.FogExp2(0xe0f0ff, 0.0015); // Exponential fog, horizon color

            // HDRI env for reflections only
            if (!pmremGen) pmremGen = new THREE.PMREMGenerator(renderer);
            new THREE.RGBELoader().load(PhotoConfig.HDRI_URL, (hdr)=>{
                const tex = pmremGen.fromEquirectangular(hdr).texture;
                envMap = tex;
                scene.environment = envMap; // For reflections on materials
                hdr.dispose();
            });
            
            // Create photorealistic sky gradient (3-color)
            const skyGeo = new THREE.SphereGeometry(800, 32, 15);
            const skyMat = new THREE.ShaderMaterial({
                uniforms: {
                    topColor: { value: new THREE.Color(0x0055dd) },      // Deep blue sky
                    midColor: { value: new THREE.Color(0x4d9fff) },      // Mid blue
                    bottomColor: { value: new THREE.Color(0xffffff) },   // Horizon white
                    offset: { value: 33 },
                    exponent: { value: 0.6 }
                },
                vertexShader: `
                    varying vec3 vWorldPosition;
                    void main() {
                        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                        vWorldPosition = worldPosition.xyz;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 topColor;
                    uniform vec3 midColor;
                    uniform vec3 bottomColor;
                    uniform float offset;
                    uniform float exponent;
                    varying vec3 vWorldPosition;
                    void main() {
                        float h = normalize(vWorldPosition + offset).y;
                        h = max(pow(max(h, 0.0), exponent), 0.0);
                        
                        // 3-color gradient: horizon -> mid -> top
                        vec3 color;
                        if (h < 0.5) {
                            color = mix(bottomColor, midColor, h * 2.0);
                        } else {
                            color = mix(midColor, topColor, (h - 0.5) * 2.0);
                        }
                        
                        gl_FragColor = vec4(color, 1.0);
                    }
                `,
                side: THREE.BackSide
            });
            skyboxMesh = new THREE.Mesh(skyGeo, skyMat);
            skyboxMesh.renderOrder = -1;
            scene.add(skyboxMesh);
            
            // Add sun disk for realism
            const sunGeo = new THREE.SphereGeometry(15, 16, 16);
            const sunMat = new THREE.MeshBasicMaterial({
                color: 0xffffdd,
                fog: false
            });
            const sunMesh = new THREE.Mesh(sunGeo, sunMat);
            sunMesh.position.set(450, 350, 450); // Position relative to sun direction
            sunMesh.userData.isSun = true;
            scene.add(sunMesh);
            
            // Create rolling hillside terrain with enhanced detail
            const hillGeo = new THREE.PlaneGeometry(800, 800, 80, 80); // Increased from 50x50 to 80x80
            const vertices = hillGeo.attributes.position.array;
            
            // Add vertex colors for grass variation
            const colors = new Float32Array(vertices.length);
            
            // Create rolling hills with multiple waves
            for (let i = 0; i < vertices.length; i += 3) {
                const x = vertices[i];
                const z = vertices[i + 1];
                const distance = Math.sqrt(x * x + z * z);
                
                // Multiple sine waves for natural-looking hills
                let height = Math.sin(x * 0.01) * 8 + Math.cos(z * 0.012) * 6;
                height += Math.sin(x * 0.03 + z * 0.02) * 3;
                height += Math.sin(distance * 0.008) * 12; // Increased amplitude
                height -= distance * 0.02; // Gentle slope down
                
                // Add valleys and ridges
                height += Math.sin(x * 0.005) * Math.cos(z * 0.006) * 5;
                
                vertices[i + 2] = height;
                
                // Color variation (lighter and darker grass patches)
                const colorVariation = 0.8 + Math.random() * 0.4; // 0.8 to 1.2
                const heightFactor = 1.0 - (distance / 800) * 0.3; // Darker in distance
                const finalColor = colorVariation * heightFactor;
                
                colors[i] = finalColor;     // R
                colors[i + 1] = finalColor; // G
                colors[i + 2] = finalColor; // B
            }
            
            hillGeo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            hillGeo.computeVertexNormals();
            
            // Enhanced grass material with roughness variation
            const hillMat = new THREE.MeshStandardMaterial({
                color: 0x4a7c2f,
                roughness: 0.9,
                metalness: 0.0,
                flatShading: false,
                vertexColors: true // Use vertex colors for variation
            });
            
            const hillMesh = new THREE.Mesh(hillGeo, hillMat);
            hillMesh.rotation.x = -Math.PI / 2;
            hillMesh.position.y = -15; // Lower than the ground plane
            hillMesh.receiveShadow = true;
            hillMesh.userData.isHillside = true;
            scene.add(hillMesh);
            
            // Hide original ground in photo mode
            ground.visible = false;

            // Swap to enhanced PBR materials
            forEachMesh((m)=>{
                const old = OriginalMats.get(m);
                if (!old.userData?.__pbrClone){
                    let pbr;
                    if (m === tower) {
                        // Tower: Painted metal (more metallic, less rough)
                        pbr = new THREE.MeshPhysicalMaterial({
                            color: 0xe5e5e5,
                            metalness: 0.85,
                            roughness: 0.2,
                            clearcoat: 0.3,
                            clearcoatRoughness: 0.25,
                            envMapIntensity: 1.2
                        });
                    } else if (m === nacelle) {
                        // Nacelle: Painted metal housing
                        pbr = new THREE.MeshPhysicalMaterial({
                            color: 0xf0f0f0,
                            metalness: 0.8,
                            roughness: 0.25,
                            clearcoat: 0.4,
                            clearcoatRoughness: 0.2,
                            envMapIntensity: 1.2
                        });
                    } else if (m === hub) {
                        // Hub: Cast iron/steel (darker, more metal)
                        pbr = new THREE.MeshPhysicalMaterial({
                            color: 0x666666,
                            metalness: 0.8,
                            roughness: 0.3,
                            clearcoat: 0.2,
                            clearcoatRoughness: 0.4,
                            envMapIntensity: 1.0
                        });
                    } else if (m === ground) {
                        // Ground (not used in photo mode, but handle anyway)
                        pbr = new THREE.MeshStandardMaterial({
                            color: 0x4a7c59,
                            roughness: 0.9,
                            metalness: 0.0
                        });
                    } else {
                        // Blades: Composite material with clearcoat
                        pbr = new THREE.MeshPhysicalMaterial({
                            color: 0xdddddd,
                            metalness: 0.1,
                            roughness: 0.4,
                            clearcoat: 0.6, // Glossy composite finish
                            clearcoatRoughness: 0.25,
                            envMapIntensity: 0.8
                        });
                    }
                    old.userData = old.userData || {};
                    old.userData.__pbrClone = pbr;
                    m.material = pbr;
                } else {
                    m.material = old.userData.__pbrClone;
                }
            });

            // Keep your load heatmap‚Äîuse emissive so PBR still reads
            bladeSegments.forEach(seg=>{
                seg.material.emissive = new THREE.Color(0x000000);
                seg.material.emissiveIntensity = 0.6;
            });

            // Enhanced postprocessing stack
            composer = new THREE.EffectComposer(renderer);
            renderPass = new THREE.RenderPass(scene, camera);
            composer.addPass(renderPass);

            // Subtle bloom for highlights (reduced for realism)
            bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                0.25,  // Reduced strength (was 0.35)
                0.8,   // Radius
                0.9    // Higher threshold (was 0.85) - less bloom on normal objects
            );
            composer.addPass(bloomPass);

            // Only add bokeh if enabled (reduces background blur)
            if (PhotoConfig.useBokeh) {
                bokehPass = new THREE.BokehPass(scene, camera, {
                    focus: PhotoConfig.bokehFocusFar,
                    aperture: PhotoConfig.bokehAperture,
                    maxblur: PhotoConfig.bokehMaxBlur
                });
                composer.addPass(bokehPass);
            }

            fxaaPass = new THREE.ShaderPass(THREE.FXAAShader);
            fxaaPass.material.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight);
            composer.addPass(fxaaPass);

            // Optional: lighten fog or remove for hero look
            scene.fog = null;
        }

        function disablePhotoMode(){
            if (!isPhotoMode) return;
            isPhotoMode = false;

            // Restore renderer defaults
            renderer.physicallyCorrectLights = false;
            renderer.toneMapping = THREE.NoToneMapping;
            renderer.toneMappingExposure = 1.0;

            // Restore simple light intensity and color
            directionalLight.intensity = OriginalLook.dirLightIntensity;
            directionalLight.color.setHex(0xffffff);
            directionalLight.position.set(50, 50, 50);

            // Remove photo mode lights (hemisphere and rim light)
            scene.children.forEach((child, index) => {
                if (child.userData && child.userData.isPhotoModeLight) {
                    scene.remove(child);
                }
            });

            // Restore background/fog and remove skybox + sun
            scene.environment = null;
            scene.background = OriginalLook.background || new THREE.Color(0x87ceeb);
            scene.fog = new THREE.Fog(0x87ceeb, 50, 200);
            
            // Remove skybox
            if (skyboxMesh) {
                scene.remove(skyboxMesh);
                skyboxMesh.geometry.dispose();
                skyboxMesh.material.dispose();
                skyboxMesh = null;
            }
            
            // Remove sun disk
            scene.children.forEach(child => {
                if (child.userData && child.userData.isSun) {
                    scene.remove(child);
                    child.geometry.dispose();
                    child.material.dispose();
                }
            });
            
            // Remove hillside and restore original ground
            scene.children.forEach(child => {
                if (child.userData && child.userData.isHillside) {
                    scene.remove(child);
                    child.geometry.dispose();
                    child.material.dispose();
                }
            });
            ground.visible = true;

            // Restore original materials
            forEachMesh((m)=>{
                const orig = OriginalMats.get(m);
                if (orig) m.material = orig;
            });

            // Kill post stack
            composer = null; renderPass = null; bloomPass = null; bokehPass = null; fxaaPass = null;
        }
        
        // Update plot data
        function updatePlotData(omega) {
            const targetRadius = turbineParams.radialStation * turbineParams.bladeRadius;
            const bladeLifts = [];
            const bladeMomentsY = [];
            const bladeMomentsZ = [];
            let totalLift = 0;
            let totalMomentY = 0;  // Vertical bending moment (nodding)
            let totalMomentZ = 0;  // Horizontal bending moment (yawing)
            
            blades.forEach((blade, bladeIndex) => {
                // Use the azimuth that was stored when thrust was calculated
                const azimuth = blade.userData.currentAzimuth || 0;
                
                // Find segment closest to target radius
                let closestSegment = null;
                let minDist = Infinity;
                blade.segments.forEach(segment => {
                    const dist = Math.abs(segment.userData.radius - targetRadius);
                    if (dist < minDist) {
                        minDist = dist;
                        closestSegment = segment;
                    }
                });
                
                if (closestSegment) {
                    const thrust = closestSegment.userData.thrust || 0;
                    bladeLifts.push(thrust);
                    
                    // Bending moment in non-rotating frame
                    // Each blade creates a moment about the tower base
                    const momentArm = closestSegment.userData.radius;
                    
                    // Decompose into fixed frame components using the stored azimuth
                    const momentY = thrust * momentArm * Math.sin(azimuth);   // Yawing (about vertical Y-axis)
                    const momentZ = -thrust * momentArm * Math.cos(azimuth);  // Nodding (about horizontal Z-axis)
                    
                    bladeMomentsY.push(momentY);
                    bladeMomentsZ.push(momentZ);
                    
                    totalLift += thrust;
                    totalMomentY += momentY;
                    totalMomentZ += momentZ;
                } else {
                    bladeLifts.push(0);
                    bladeMomentsY.push(0);
                    bladeMomentsZ.push(0);
                }
            });
            
            // Store data with continuous time for scrolling x-axis
            // Increment time value based on rotation speed
            const deltaTime = omega * (2 * Math.PI) / (60 * 60); // radians per frame
            plotData.timeValue += deltaTime;
            
            // Check for TDC crossing (when blade 1 azimuth crosses 0¬∞/360¬∞)
            const blade1Azimuth = blades[0].userData.currentAzimuth || 0;
            const blade1AzimuthDeg = ((blade1Azimuth * 180 / Math.PI) % 360 + 360) % 360;
            
            // Detect TDC crossing by checking if azimuth wrapped around
            if (blades[0].userData.previousAzimuth !== undefined) {
                const prevAzimuth = blades[0].userData.previousAzimuth;
                const prevAzimuthDeg = ((prevAzimuth * 180 / Math.PI) % 360 + 360) % 360;
                // Check if we crossed from 350-360 to 0-10 degrees
                if (prevAzimuthDeg > 350 && blade1AzimuthDeg < 10) {
                    plotData.tdcMarkers.push(plotData.timeValue);
                }
            }
            blades[0].userData.previousAzimuth = blade1Azimuth;
            
            plotData.time.push(plotData.timeValue.toFixed(3));
            
            for (let i = 0; i < turbineParams.numBlades; i++) {
                if (plotData.bladeLift[i]) {
                    plotData.bladeLift[i].push(bladeLifts[i] || 0);
                    plotData.bladeMomentY[i].push(bladeMomentsY[i] || 0);
                    plotData.bladeMomentZ[i].push(bladeMomentsZ[i] || 0);
                }
            }
            plotData.totalLift.push(totalLift);
            plotData.totalMomentY.push(totalMomentY);
            plotData.totalMomentZ.push(totalMomentZ);
            
            // Fourier data collection - collect for exactly one revolution
            if (!turbineParams.paused && omega > 0) {
                // Start collection if not already collecting
                if (!fourierData.collecting && !fourierData.complete) {
                    startFourierCollection();
                }
                
                // Check if we've completed one revolution
                if (fourierData.collecting) {
                    const currentAzimuth = rotorGroup.rotation.x;
                    const angleTraveled = currentAzimuth - fourierData.startAzimuth;
                    const angleInDegrees = (angleTraveled * 180 / Math.PI) % 360;
                    
                    // Check if enough angular distance has passed since last collection
                    const shouldCollect = (angleInDegrees - fourierData.lastCollectionTime) >= fourierData.samplingInterval;
                    
                    // Store data point at specified sampling interval
                    if (shouldCollect && bladeLifts[0] !== undefined) {
                        fourierData.bladeLift.push(bladeLifts[0]);
                        fourierData.bladeMomentY.push(bladeMomentsY[0]);
                        fourierData.bladeMomentZ.push(bladeMomentsZ[0]);
                        fourierData.totalLift.push(totalLift);
                        fourierData.totalMomentY.push(totalMomentY);
                        fourierData.totalMomentZ.push(totalMomentZ);
                        fourierData.lastCollectionTime = angleInDegrees;
                    }
                    
                    // Check if we've completed one full revolution (2œÄ radians)
                    if (angleTraveled >= 2 * Math.PI) {
                        fourierData.collecting = false;
                        fourierData.complete = true;
                        // After first fast collection, switch to normal mode for subsequent collections
                        if (fourierData.fastMode) {
                            fourierData.fastMode = false;
                            // Clear all trace data after fast collection completes
                            initPlotData();
                            updateCharts();
                        }
                    }
                }
            }
            
            // Limit data to exactly 2 revolutions (720¬∞)
            // Calculate max points based on angular resolution
            const degreesPerRevolution = 360;
            const maxRevolutions = 2;
            const maxDataPoints = Math.ceil((degreesPerRevolution * maxRevolutions) / turbineParams.angularResolution);
            
            // Once we have max points, start removing from the left (scrolling)
            if (plotData.time.length > maxDataPoints) {
                plotData.time.shift();
                plotData.bladeLift.forEach(arr => arr.shift());
                plotData.bladeMomentY.forEach(arr => arr.shift());
                plotData.bladeMomentZ.forEach(arr => arr.shift());
                plotData.totalLift.shift();
                plotData.totalMomentY.shift();
                plotData.totalMomentZ.shift();
                
                // Keep only the 2 most recent TDC markers
                if (plotData.tdcMarkers.length > 2) {
                    plotData.tdcMarkers.shift();
                }
            }
            
            // Update charts
            updateCharts();
        }
        
        // Update chart displays
        function updateCharts() {
            if (plotData.bladeLift.length !== turbineParams.numBlades) {
                // Data arrays don't match blade count, skip update
                return;
            }
            
            // Calculate dynamic x-axis bounds based on current data
            let xMin = 0;
            let xMax = 4 * Math.PI; // Default to 4œÄ (720¬∞)
            
            if (plotData.time.length > 0) {
                const firstTime = parseFloat(plotData.time[0]);
                const lastTime = parseFloat(plotData.time[plotData.time.length - 1]);
                
                // If we haven't filled the buffer yet, show from 0 to current max (clipped to 4œÄ)
                const maxDataPoints = Math.ceil((360 * 2) / turbineParams.angularResolution);
                if (plotData.time.length < maxDataPoints) {
                    xMin = 0;
                    xMax = Math.min(lastTime, 4 * Math.PI); // Clip to data or 4œÄ, whichever is smaller
                } else {
                    // Once full, scroll with the data
                    xMin = firstTime;
                    xMax = lastTime;
                }
            }
            
            // Get current azimuth for position indicator
            const currentAzimuthDeg = ((rotorGroup.rotation.x * 180 / Math.PI) % 360);
            const normalizedCurrentAzimuth = currentAzimuthDeg >= 0 ? currentAzimuthDeg : currentAzimuthDeg + 360;
            
            // Update lift chart
            liftChart.data.labels = plotData.time;
            liftChart.options.scales.x.min = xMin;
            liftChart.options.scales.x.max = xMax;
            for (let i = 0; i < turbineParams.numBlades; i++) {
                if (liftChart.data.datasets[i] && plotData.bladeLift[i]) {
                    liftChart.data.datasets[i].data = plotData.bladeLift[i];
                }
            }
            if (liftChart.data.datasets[turbineParams.numBlades]) {
                liftChart.data.datasets[turbineParams.numBlades].data = plotData.totalLift;
            }
            // Store current azimuth for drawing indicator
            liftChart.currentAzimuth = turbineParams.paused ? normalizedCurrentAzimuth : null;
            liftChart.update('none');
            
            // Update moment Y chart (nodding)
            momentYChart.data.labels = plotData.time;
            momentYChart.options.scales.x.min = xMin;
            momentYChart.options.scales.x.max = xMax;
            for (let i = 0; i < turbineParams.numBlades; i++) {
                if (momentYChart.data.datasets[i] && plotData.bladeMomentY[i]) {
                    momentYChart.data.datasets[i].data = plotData.bladeMomentY[i];
                }
            }
            if (momentYChart.data.datasets[turbineParams.numBlades]) {
                momentYChart.data.datasets[turbineParams.numBlades].data = plotData.totalMomentY;
            }
            momentYChart.currentAzimuth = turbineParams.paused ? normalizedCurrentAzimuth : null;
            momentYChart.update('none');
            
            // Update moment Z chart (yawing)
            momentZChart.data.labels = plotData.time;
            momentZChart.options.scales.x.min = xMin;
            momentZChart.options.scales.x.max = xMax;
            for (let i = 0; i < turbineParams.numBlades; i++) {
                if (momentZChart.data.datasets[i] && plotData.bladeMomentZ[i]) {
                    momentZChart.data.datasets[i].data = plotData.bladeMomentZ[i];
                }
            }
            if (momentZChart.data.datasets[turbineParams.numBlades]) {
                momentZChart.data.datasets[turbineParams.numBlades].data = plotData.totalMomentZ;
            }
            momentZChart.currentAzimuth = turbineParams.paused ? normalizedCurrentAzimuth : null;
            momentZChart.update('none');
            
            // Update Fourier analysis if we have enough data
            updateFourierDisplay();
        }
        
        // Update Fourier analysis display
        function updateFourierDisplay() {
            const thrustContent = document.getElementById('fourier-thrust-content');
            const momentYContent = document.getElementById('fourier-moment-y-content');
            const momentZContent = document.getElementById('fourier-moment-z-content');
            
            // Check if elements exist (they might not if we're still loading)
            if (!thrustContent || !momentYContent || !momentZContent) return;
            
            // Check collection status
            if (fourierData.collecting) {
                const mode = fourierData.fastMode ? ' (fast ' + fourierData.speedMultiplier + 'x)' : '';
                const statusMsg = '<p style="font-size: 0.85em; color: #999;">Collecting... (' + fourierData.bladeLift.length + ' pts)</p>';
                thrustContent.innerHTML = statusMsg;
                momentYContent.innerHTML = statusMsg;
                momentZContent.innerHTML = statusMsg;
                return;
            }
            
            if (!fourierData.complete || fourierData.bladeLift.length < 10) {
                const waitMsg = '<p style="font-size: 0.85em; color: #999;">Waiting...</p>';
                thrustContent.innerHTML = waitMsg;
                momentYContent.innerHTML = waitMsg;
                momentZContent.innerHTML = waitMsg;
                return;
            }
            
            // Use collected Fourier data
            const blade1Thrust = fourierData.bladeLift;
            const blade1MomentY = fourierData.bladeMomentY;
            const blade1MomentZ = fourierData.bladeMomentZ;
            const totalThrust = fourierData.totalLift;
            const totalMomentY = fourierData.totalMomentY;
            const totalMomentZ = fourierData.totalMomentZ;
            
            // Perform Fourier analysis (up to nP where n = numBlades)
            const maxHarmonic = Math.min(turbineParams.numBlades, 4);
            const blade1ThrustFourier = analyzeFourier(blade1Thrust, maxHarmonic);
            const blade1MomentYFourier = analyzeFourier(blade1MomentY, maxHarmonic);
            const blade1MomentZFourier = analyzeFourier(blade1MomentZ, maxHarmonic);
            const totalThrustFourier = analyzeFourier(totalThrust, maxHarmonic);
            const totalMomentYFourier = analyzeFourier(totalMomentY, maxHarmonic);
            const totalMomentZFourier = analyzeFourier(totalMomentZ, maxHarmonic);
            
            // Calculate percentages of total
            function calculatePercent(fourier) {
                const totalAmplitude = fourier.reduce((sum, h) => sum + Math.abs(h.amplitude), 0);
                return fourier.map(h => ({
                    ...h,
                    percent: totalAmplitude > 0 ? (Math.abs(h.amplitude) / totalAmplitude * 100) : 0
                }));
            }
            
            const blade1ThrustWithPercent = calculatePercent(blade1ThrustFourier);
            const totalThrustWithPercent = calculatePercent(totalThrustFourier);
            const blade1MomentYWithPercent = calculatePercent(blade1MomentYFourier);
            const blade1MomentZWithPercent = calculatePercent(blade1MomentZFourier);
            const totalMomentYWithPercent = calculatePercent(totalMomentYFourier);
            const totalMomentZWithPercent = calculatePercent(totalMomentZFourier);
            
            // Build HTML
            let html = '';
            
            // Blade 1 Thrust
            html += '<h5 style="margin: 10px 0 5px 0; font-size: 0.95em;">Blade 1 Thrust</h5>';
            html += '<table style="width: 100%; font-size: 0.8em; border-collapse: collapse;">';
            html += '<thead><tr style="background: #ddd;">';
            html += '<th style="padding: 3px; text-align: center;">nP</th>';
            html += '<th style="padding: 3px; text-align: right;">Amp</th>';
            html += '<th style="padding: 3px; text-align: right;">%</th>';
            html += '</tr></thead><tbody>';
            blade1ThrustWithPercent.forEach((h, idx) => {
                html += `<tr style="background: ${idx % 2 === 0 ? '#f9f9f9' : '#fff'};">`;
                html += `<td style="padding: 3px; text-align: center;">${h.harmonic}P</td>`;
                html += `<td style="padding: 3px; text-align: right;">${h.amplitude.toFixed(2)}</td>`;
                html += `<td style="padding: 3px; text-align: right;">${h.percent.toFixed(1)}%</td>`;
                html += '</tr>';
            });
            html += '</tbody></table>';
            
            // Total Rotor Thrust
            html += '<h5 style="margin: 15px 0 5px 0; font-size: 0.95em;">Total Rotor Thrust</h5>';
            html += '<table style="width: 100%; font-size: 0.8em; border-collapse: collapse;">';
            html += '<thead><tr style="background: #ddd;">';
            html += '<th style="padding: 3px; text-align: center;">nP</th>';
            html += '<th style="padding: 3px; text-align: right;">Amp</th>';
            html += '<th style="padding: 3px; text-align: right;">%</th>';
            html += '</tr></thead><tbody>';
            totalThrustWithPercent.forEach((h, idx) => {
                html += `<tr style="background: ${idx % 2 === 0 ? '#f9f9f9' : '#fff'};">`;
                html += `<td style="padding: 3px; text-align: center;">${h.harmonic}P</td>`;
                html += `<td style="padding: 3px; text-align: right;">${h.amplitude.toFixed(2)}</td>`;
                html += `<td style="padding: 3px; text-align: right;">${h.percent.toFixed(1)}%</td>`;
                html += '</tr>';
            });
            html += '</tbody></table>';
            
            // Blade 1 Yawing Moment
            html += '<h5 style="margin: 15px 0 5px 0; font-size: 0.95em;">Blade 1 M_y (Yawing)</h5>';
            html += '<table style="width: 100%; font-size: 0.8em; border-collapse: collapse;">';
            html += '<thead><tr style="background: #ddd;">';
            html += '<th style="padding: 3px; text-align: center;">nP</th>';
            html += '<th style="padding: 3px; text-align: right;">Amp</th>';
            html += '<th style="padding: 3px; text-align: right;">%</th>';
            html += '</tr></thead><tbody>';
            blade1MomentYWithPercent.forEach((h, idx) => {
                html += `<tr style="background: ${idx % 2 === 0 ? '#f9f9f9' : '#fff'};">`;
                html += `<td style="padding: 3px; text-align: center;">${h.harmonic}P</td>`;
                html += `<td style="padding: 3px; text-align: right;">${h.amplitude.toFixed(2)}</td>`;
                html += `<td style="padding: 3px; text-align: right;">${h.percent.toFixed(1)}%</td>`;
                html += '</tr>';
            });
            html += '</tbody></table>';
            
            // Blade 1 Nodding Moment
            html += '<h5 style="margin: 15px 0 5px 0; font-size: 0.95em;">Blade 1 M_z (Nodding)</h5>';
            html += '<table style="width: 100%; font-size: 0.8em; border-collapse: collapse;">';
            html += '<thead><tr style="background: #ddd;">';
            html += '<th style="padding: 3px; text-align: center;">nP</th>';
            html += '<th style="padding: 3px; text-align: right;">Amp</th>';
            html += '<th style="padding: 3px; text-align: right;">%</th>';
            html += '</tr></thead><tbody>';
            blade1MomentZWithPercent.forEach((h, idx) => {
                html += `<tr style="background: ${idx % 2 === 0 ? '#f9f9f9' : '#fff'};">`;
                html += `<td style="padding: 3px; text-align: center;">${h.harmonic}P</td>`;
                html += `<td style="padding: 3px; text-align: right;">${h.amplitude.toFixed(2)}</td>`;
                html += `<td style="padding: 3px; text-align: right;">${h.percent.toFixed(1)}%</td>`;
                html += '</tr>';
            });
            html += '</tbody></table>';
            
            // Total Rotor Yawing Moment
            html += '<h5 style="margin: 15px 0 5px 0; font-size: 0.95em;">Total Rotor M_y (Yawing)</h5>';
            html += '<table style="width: 100%; font-size: 0.8em; border-collapse: collapse;">';
            html += '<thead><tr style="background: #ddd;">';
            html += '<th style="padding: 3px; text-align: center;">nP</th>';
            html += '<th style="padding: 3px; text-align: right;">Amp</th>';
            html += '<th style="padding: 3px; text-align: right;">%</th>';
            html += '</tr></thead><tbody>';
            totalMomentYWithPercent.forEach((h, idx) => {
                html += `<tr style="background: ${idx % 2 === 0 ? '#f9f9f9' : '#fff'};">`;
                html += `<td style="padding: 3px; text-align: center;">${h.harmonic}P</td>`;
                html += `<td style="padding: 3px; text-align: right;">${h.amplitude.toFixed(2)}</td>`;
                html += `<td style="padding: 3px; text-align: right;">${h.percent.toFixed(1)}%</td>`;
                html += '</tr>';
            });
            html += '</tbody></table>';
            
            // Total Rotor Nodding Moment
            html += '<h5 style="margin: 15px 0 5px 0; font-size: 0.95em;">Total Rotor M_z (Nodding)</h5>';
            html += '<table style="width: 100%; font-size: 0.8em; border-collapse: collapse;">';
            html += '<thead><tr style="background: #ddd;">';
            html += '<th style="padding: 3px; text-align: center;">nP</th>';
            html += '<th style="padding: 3px; text-align: right;">Amp</th>';
            html += '<th style="padding: 3px; text-align: right;">%</th>';
            html += '</tr></thead><tbody>';
            totalMomentZWithPercent.forEach((h, idx) => {
                html += `<tr style="background: ${idx % 2 === 0 ? '#f9f9f9' : '#fff'};">`;
                html += `<td style="padding: 3px; text-align: center;">${h.harmonic}P</td>`;
                html += `<td style="padding: 3px; text-align: right;">${h.amplitude.toFixed(2)}</td>`;
                html += `<td style="padding: 3px; text-align: right;">${h.percent.toFixed(1)}%</td>`;
                html += '</tr>';
            });
            html += '</tbody></table>';
            
            // Split content into three separate sections
            // Thrust tab gets blade1 and total thrust
            let thrustHtml = '';
            thrustHtml += html.substring(html.indexOf('<h5'), html.indexOf('Blade 1 M_y'));
            
            // Moment Y tab gets blade1 and total moment Y
            let momentYHtml = '';
            const myStart = html.indexOf('Blade 1 M_y');
            const myEnd = html.indexOf('Blade 1 M_z');
            momentYHtml += html.substring(myStart, myEnd);
            const totalMyStart = html.indexOf('Total Rotor M_y');
            const totalMyEnd = html.indexOf('Total Rotor M_z', totalMyStart);
            momentYHtml += html.substring(totalMyStart, totalMyEnd);
            
            // Moment Z tab gets blade1 and total moment Z
            let momentZHtml = '';
            const mzStart = html.indexOf('Blade 1 M_z');
            const mzEnd = html.indexOf('Total Rotor M_y');
            momentZHtml += html.substring(mzStart, mzEnd);
            const totalMzStart = html.indexOf('Total Rotor M_z');
            momentZHtml += html.substring(totalMzStart);
            
            thrustContent.innerHTML = thrustHtml;
            momentYContent.innerHTML = momentYHtml;
            momentZContent.innerHTML = momentZHtml;
        }
        
        // Rebuild charts when blade count changes
        function rebuildCharts() {
            chartDatasets = createChartDatasets();
            
            // Completely rebuild lift chart
            liftChart.data.datasets = chartDatasets.liftDatasets;
            liftChart.data.labels = [];
            liftChart.update('reset');
            
            // Completely rebuild moment Y chart
            momentYChart.data.datasets = chartDatasets.momentYDatasets;
            momentYChart.data.labels = [];
            momentYChart.update('reset');
            
            // Completely rebuild moment Z chart
            momentZChart.data.datasets = chartDatasets.momentZDatasets;
            momentZChart.data.labels = [];
            momentZChart.update('reset');
        }
        
        // Create chart datasets
        function createChartDatasets() {
            const colors = [
                'rgb(255, 99, 132)',
                'rgb(54, 162, 235)',
                'rgb(75, 192, 192)',
                'rgb(255, 206, 86)',
                'rgb(153, 102, 255)',
                'rgb(255, 159, 64)',
                'rgb(199, 199, 199)',
                'rgb(83, 102, 255)',
                'rgb(255, 99, 255)',
                'rgb(99, 255, 132)',
                'rgb(255, 132, 99)',
                'rgb(132, 99, 255)',
                'rgb(99, 255, 255)',
                'rgb(255, 255, 99)',
                'rgb(192, 75, 192)',
                'rgb(75, 192, 75)',
                'rgb(192, 192, 75)',
                'rgb(75, 75, 192)',
                'rgb(192, 75, 75)',
                'rgb(128, 128, 128)'
            ];
            
            const liftDatasets = [];
            const momentYDatasets = [];
            const momentZDatasets = [];
            
            // Individual blade datasets
            for (let i = 0; i < turbineParams.numBlades; i++) {
                liftDatasets.push({
                    label: `Blade ${i + 1} Thrust`,
                    data: [],
                    borderColor: colors[i % colors.length],
                    backgroundColor: colors[i % colors.length],
                    borderWidth: 1,
                    pointRadius: 0
                });
                
                momentYDatasets.push({
                    label: `Blade ${i + 1} My`,
                    data: [],
                    borderColor: colors[i % colors.length],
                    backgroundColor: colors[i % colors.length],
                    borderWidth: 1,
                    pointRadius: 0
                });
                
                momentZDatasets.push({
                    label: `Blade ${i + 1} Mz`,
                    data: [],
                    borderColor: colors[i % colors.length],
                    backgroundColor: colors[i % colors.length],
                    borderWidth: 1,
                    pointRadius: 0
                });
            }
            
            // Total datasets
            liftDatasets.push({
                label: 'Total Thrust',
                data: [],
                borderColor: 'rgb(0, 0, 0)',
                backgroundColor: 'rgb(0, 0, 0)',
                borderWidth: 2,
                pointRadius: 0
            });
            
            momentYDatasets.push({
                label: 'Total My',
                data: [],
                borderColor: 'rgb(0, 0, 0)',
                backgroundColor: 'rgb(0, 0, 0)',
                borderWidth: 2,
                pointRadius: 0
            });
            
            momentZDatasets.push({
                label: 'Total Mz',
                data: [],
                borderColor: 'rgb(0, 0, 0)',
                backgroundColor: 'rgb(0, 0, 0)',
                borderWidth: 2,
                pointRadius: 0
            });
            
            return { liftDatasets, momentYDatasets, momentZDatasets };
        }
        
        // Initialize charts
        let chartDatasets = createChartDatasets();
        
        // Custom plugin to draw current position indicator
        const currentPositionPlugin = {
            id: 'currentPosition',
            afterDraw: (chart) => {
                if (chart.currentAzimuth !== null && chart.currentAzimuth !== undefined) {
                    const ctx = chart.ctx;
                    const xAxis = chart.scales.x;
                    const yAxis = chart.scales.y;
                    
                    // Find the x position for current azimuth
                    const labels = chart.data.labels;
                    let xPos = null;
                    
                    // Find closest label to current azimuth
                    let minDiff = Infinity;
                    let closestIndex = 0;
                    for (let i = 0; i < labels.length; i++) {
                        const labelValue = parseFloat(labels[i]);
                        const diff = Math.abs(labelValue - chart.currentAzimuth);
                        if (diff < minDiff) {
                            minDiff = diff;
                            closestIndex = i;
                        }
                    }
                    
                    if (closestIndex >= 0 && closestIndex < labels.length) {
                        xPos = xAxis.getPixelForValue(closestIndex);
                    }
                    
                    if (xPos !== null) {
                        ctx.save();
                        ctx.beginPath();
                        ctx.strokeStyle = 'rgba(255, 0, 0, 0.8)';
                        ctx.lineWidth = 2;
                        ctx.setLineDash([5, 5]);
                        ctx.moveTo(xPos, yAxis.top);
                        ctx.lineTo(xPos, yAxis.bottom);
                        ctx.stroke();
                        ctx.restore();
                    }
                }
            }
        };
        
        // Plugin to draw TDC (Top Dead Center) markers
        const tdcMarkerPlugin = {
            id: 'tdcMarker',
            afterDatasetsDraw(chart) {
                const { ctx, chartArea, scales } = chart;
                if (!chartArea || !plotData.tdcMarkers) return;
                
                ctx.save();
                ctx.strokeStyle = 'rgba(255, 0, 0, 0.6)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                
                plotData.tdcMarkers.forEach(tdcTime => {
                    const x = scales.x.getPixelForValue(tdcTime);
                    if (x >= chartArea.left && x <= chartArea.right) {
                        ctx.beginPath();
                        ctx.moveTo(x, chartArea.top);
                        ctx.lineTo(x, chartArea.bottom);
                        ctx.stroke();
                        
                        // Draw "TDC" label
                        ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
                        ctx.font = '10px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('TDC', x, chartArea.top - 5);
                    }
                });
                
                ctx.restore();
            }
        };
        
        const liftChartCtx = document.getElementById('lift-chart').getContext('2d');
        let liftChart = new Chart(liftChartCtx, {
            type: 'line',
            data: {
                labels: [],
                datasets: chartDatasets.liftDatasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Blade Thrust'
                    },
                    legend: {
                        display: true,
                        position: 'top'
                    }
                },
                scales: {
                    x: {
                        display: true,
                        type: 'linear',
                        title: {
                            display: true,
                            text: 'Time (rad)'
                        },
                        ticks: {
                            display: false  // Hide tick numbers
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Thrust'
                        }
                    }
                }
            },
            plugins: [currentPositionPlugin, tdcMarkerPlugin]
        });
        
        const momentYChartCtx = document.getElementById('moment-y-chart').getContext('2d');
        let momentYChart = new Chart(momentYChartCtx, {
            type: 'line',
            data: {
                labels: [],
                datasets: chartDatasets.momentYDatasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Nodding Moment (My)'
                    },
                    legend: {
                        display: true,
                        position: 'top'
                    }
                },
                scales: {
                    x: {
                        display: true,
                        type: 'linear',
                        title: {
                            display: true,
                            text: 'Time (rad)'
                        },
                        ticks: {
                            display: false  // Hide tick numbers
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Moment Y'
                        }
                    }
                }
            },
            plugins: [currentPositionPlugin, tdcMarkerPlugin]
        });
        
        const momentZChartCtx = document.getElementById('moment-z-chart').getContext('2d');
        let momentZChart = new Chart(momentZChartCtx, {
            type: 'line',
            data: {
                labels: [],
                datasets: chartDatasets.momentZDatasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Yawing Moment (Mz)'
                    },
                    legend: {
                        display: true,
                        position: 'top'
                    }
                },
                scales: {
                    x: {
                        display: true,
                        type: 'linear',
                        title: {
                            display: true,
                            text: 'Time (rad)'
                        },
                        ticks: {
                            display: false  // Hide tick numbers
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Moment Z'
                        }
                    }
                }
            },
            plugins: [currentPositionPlugin, tdcMarkerPlugin]
        });
        
        // Now that charts are initialized, create the initial blades
        updateBladeCount();
        
        // Event listeners
        document.getElementById('wind-speed').addEventListener('input', (e) => {
            turbineParams.windSpeed = parseFloat(e.target.value);
            document.getElementById('wind-speed-value').textContent = turbineParams.windSpeed.toFixed(1);
            resetFourierCollection();
        });
        
        document.getElementById('shaft-speed').addEventListener('input', (e) => {
            turbineParams.shaftSpeed = parseFloat(e.target.value);
            document.getElementById('shaft-speed-value').textContent = turbineParams.shaftSpeed.toFixed(1);
            resetFourierCollection();
        });
        
        document.getElementById('pause-rotation').addEventListener('change', (e) => {
            turbineParams.paused = e.target.checked;
            if (turbineParams.paused) {
                // When pausing, set manual rotation to current rotation
                const currentRotationDeg = (rotorGroup.rotation.x * 180 / Math.PI) % 360;
                turbineParams.manualRotation = currentRotationDeg >= 0 ? currentRotationDeg : currentRotationDeg + 360;
                document.getElementById('manual-rotation').value = turbineParams.manualRotation;
                document.getElementById('manual-rotation-value').textContent = turbineParams.manualRotation.toFixed(1);
            }
        });
        
        document.getElementById('manual-rotation').addEventListener('input', (e) => {
            turbineParams.manualRotation = parseFloat(e.target.value);
            document.getElementById('manual-rotation-value').textContent = turbineParams.manualRotation.toFixed(1);
            if (turbineParams.paused) {
                // Directly set rotor rotation when paused
                rotorGroup.rotation.x = turbineParams.manualRotation * Math.PI / 180;
            }
        });
        
        document.getElementById('blade-pitch').addEventListener('input', (e) => {
            turbineParams.bladePitch = parseFloat(e.target.value);
            document.getElementById('blade-pitch-value').textContent = turbineParams.bladePitch.toFixed(1);
            // Update visual blade pitch
            blades.forEach(blade => {
                blade.pitchGroup.rotation.y = turbineParams.bladePitch * Math.PI / 180;
            });
        });
        
        document.getElementById('num-blades').addEventListener('input', (e) => {
            turbineParams.numBlades = parseInt(e.target.value);
            document.getElementById('num-blades-value').textContent = turbineParams.numBlades;
            updateBladeCount();
        });
        
        document.getElementById('yaw').addEventListener('input', (e) => {
            turbineParams.yawAngle = parseFloat(e.target.value);
            document.getElementById('yaw-value').textContent = turbineParams.yawAngle.toFixed(1);
            nacelleGroup.rotation.y = turbineParams.yawAngle * Math.PI / 180;
            resetFourierCollection();
        });
        
        document.getElementById('inflow').addEventListener('input', (e) => {
            turbineParams.inflowAngle = parseFloat(e.target.value);
            document.getElementById('inflow-value').textContent = turbineParams.inflowAngle.toFixed(1);
            resetFourierCollection();
        });
        
        document.getElementById('show-axes').addEventListener('change', (e) => {
            const show = e.target.checked;
            sceneAxes.visible = show;
            rotorAxes.visible = show;
            nacelleAxes.visible = show;
        });
        
        document.getElementById('photo-mode').addEventListener('change', (e) => {
            if (e.target.checked) enablePhotoMode();
            else disablePhotoMode();
        });
        
        
        document.getElementById('show-heatmap').addEventListener('change', (e) => {
            turbineParams.showHeatmap = e.target.checked;
        });
        
        document.getElementById('show-vectors').addEventListener('change', (e) => {
            turbineParams.showVectors = e.target.checked;
        });
        
        document.getElementById('vector-mode').addEventListener('change', (e) => {
            turbineParams.vectorMode = e.target.value;
            console.log('Vector mode changed to:', turbineParams.vectorMode);
        });
        
        document.getElementById('vector-scale').addEventListener('input', (e) => {
            turbineParams.vectorScale = parseFloat(e.target.value);
            document.getElementById('vector-scale-value').textContent = turbineParams.vectorScale.toFixed(3);
        });
        
        document.getElementById('angular-resolution').addEventListener('input', (e) => {
            turbineParams.angularResolution = parseFloat(e.target.value);
            const value = turbineParams.angularResolution;
            // Display with appropriate precision
            if (value < 1) {
                document.getElementById('angular-res-value').textContent = value.toFixed(3);
            } else {
                document.getElementById('angular-res-value').textContent = value.toFixed(1);
            }
            // Reset plot data when resolution changes
            initPlotData();
            rebuildCharts();
            for (let i = 0; i < turbineParams.numBlades; i++) {
                plotData.bladeLift[i] = [];
                plotData.bladeMomentY[i] = [];
                plotData.bladeMomentZ[i] = [];
            }
            timeCounter = 0;
            resetFourierCollection();
        });
        
        // Radial station control
        document.getElementById('radial-station').addEventListener('input', (e) => {
            const percent = parseInt(e.target.value);
            turbineParams.radialStation = percent / 100;
            document.getElementById('station-value').textContent = percent;
            // Reset plot data when station changes
            initPlotData();
            rebuildCharts();
            // Reset arrays
            for (let i = 0; i < turbineParams.numBlades; i++) {
                plotData.bladeLift[i] = [];
                plotData.bladeMomentY[i] = [];
                plotData.bladeMomentZ[i] = [];
            }
            timeCounter = 0;
        });
                
        // Debug data generation
        document.getElementById('generate-debug').addEventListener('click', () => {
            generateDebugData();
        });
        
        // Generate debug table for 2-blade turbine
        function generateDebugData() {
            const output = document.getElementById('debug-output');
            
            output.innerHTML = '<p>Generating debug data for 2-blade turbine...</p>';
            output.innerHTML += `<p><strong>Configuration:</strong> Wind Speed=${turbineParams.windSpeed.toFixed(1)} m/s, Shaft Speed=${turbineParams.shaftSpeed.toFixed(1)} RPM, Yaw=${turbineParams.yawAngle}¬∞, Inflow=${turbineParams.inflowAngle}¬∞</p>`;
            output.innerHTML += `<p><strong>Radial Station:</strong> ${(turbineParams.radialStation * 100).toFixed(0)}% span</p>`;
            
            // Axis system info
            output.innerHTML += '<hr>';
            output.innerHTML += '<h3>Coordinate System</h3>';
            output.innerHTML += '<p><strong>THREE.js Convention:</strong> X-axis points downstream (into wind), Y-axis points up, Z-axis to the side</p>';
            output.innerHTML += '<p><strong>Rotor:</strong> Rotates about X-axis. rotation.x = angle</p>';
            output.innerHTML += '<p><strong>Blade positioning:</strong></p>';
            output.innerHTML += '<ul>';
            output.innerHTML += '<li>rotation.x = 0 ‚Üí Blade at Y+ (top of disc, 12 o\'clock)</li>';
            output.innerHTML += '<li>rotation.x = œÄ/2 ‚Üí Blade at Z+ (3 o\'clock looking downstream)</li>';
            output.innerHTML += '<li>rotation.x = œÄ ‚Üí Blade at Y- (bottom of disc, 6 o\'clock)</li>';
            output.innerHTML += '<li>rotation.x = 3œÄ/2 ‚Üí Blade at Z- (9 o\'clock looking downstream)</li>';
            output.innerHTML += '</ul>';
            output.innerHTML += '<p><strong>Expected with Yaw:</strong> Peak thrust when blade is on advancing side (Z+), minimum on retreating side (Z-)</p>';
            output.innerHTML += '<hr>';
            
            // Calculate thrust for 2 revolutions at 10-degree intervals
            const debugData = [];
            const omega = turbineParams.shaftSpeed * 2 * Math.PI / 60;
            const windSpeed = turbineParams.windSpeed;
            const yawRadians = turbineParams.yawAngle * Math.PI / 180;
            const inflowRadians = turbineParams.inflowAngle * Math.PI / 180;
            const windSpeedAxial = windSpeed * Math.cos(yawRadians);
            const windSpeedTangential = windSpeed * Math.sin(yawRadians);
            const targetRadius = turbineParams.radialStation * turbineParams.bladeRadius;
            
            // Get the chord at target radius (approximate from blade segments)
            let chord = 1.0; // default
            if (blades.length > 0 && blades[0].segments.length > 0) {
                let closestSegment = blades[0].segments[0];
                let minDist = Infinity;
                blades[0].segments.forEach(segment => {
                    const dist = Math.abs(segment.userData.radius - targetRadius);
                    if (dist < minDist) {
                        minDist = dist;
                        closestSegment = segment;
                    }
                });
                chord = closestSegment.userData.chord;
            }
            
            // Calculate for 2 revolutions at 10-degree resolution
            for (let angleDeg = 0; angleDeg < 720; angleDeg += 10) {
                const angle = angleDeg * Math.PI / 180;
                
                // Blade 1 azimuth (starts at 0)
                const azimuth1 = angle;
                const thrust1 = calculateThrustAtAzimuth(azimuth1, targetRadius, chord, omega, windSpeedAxial, windSpeedTangential, inflowRadians);
                
                // Blade 2 azimuth (180 degrees offset)
                const azimuth2 = angle + Math.PI;
                const thrust2 = calculateThrustAtAzimuth(azimuth2, targetRadius, chord, omega, windSpeedAxial, windSpeedTangential, inflowRadians);
                
                // Position descriptions
                const pos1 = getPositionDescription((azimuth1 * 180 / Math.PI) % 360);
                const pos2 = getPositionDescription((azimuth2 * 180 / Math.PI) % 360);
                
                debugData.push({
                    angle: angleDeg,
                    azimuth1Deg: (azimuth1 * 180 / Math.PI) % 360,
                    azimuth2Deg: (azimuth2 * 180 / Math.PI) % 360,
                    thrust1: thrust1,
                    thrust2: thrust2,
                    diff: Math.abs(thrust1 - thrust2),
                    pos1: pos1,
                    pos2: pos2
                });
            }
            
            // Find crossings (where thrust1 and thrust2 are approximately equal)
            const crossings = [];
            for (let i = 1; i < debugData.length; i++) {
                const prev = debugData[i-1];
                const curr = debugData[i];
                
                // Check if lines cross (sign change in difference)
                if ((prev.thrust1 - prev.thrust2) * (curr.thrust1 - curr.thrust2) < 0) {
                    // Linear interpolation to find exact crossing
                    const t = Math.abs(prev.thrust1 - prev.thrust2) / (Math.abs(prev.thrust1 - prev.thrust2) + Math.abs(curr.thrust1 - curr.thrust2));
                    const crossAngle = prev.angle + t * (curr.angle - prev.angle);
                    const crossThrust = prev.thrust1 + t * (curr.thrust1 - prev.thrust1);
                    crossings.push({ angle: crossAngle, thrust: crossThrust });
                }
            }
            
            // Build HTML table
            let html = '<h3>Debug Data Table</h3>';
            html += '<table style="border-collapse: collapse; width: 100%; font-size: 0.85em;">';
            html += '<thead><tr style="background: #667eea; color: white;">';
            html += '<th style="border: 1px solid #ddd; padding: 8px;">Rotor Angle</th>';
            html += '<th style="border: 1px solid #ddd; padding: 8px;">Blade 1 Az</th>';
            html += '<th style="border: 1px solid #ddd; padding: 8px;">Position</th>';
            html += '<th style="border: 1px solid #ddd; padding: 8px;">Blade 1 Thrust</th>';
            html += '<th style="border: 1px solid #ddd; padding: 8px;">Blade 2 Az</th>';
            html += '<th style="border: 1px solid #ddd; padding: 8px;">Position</th>';
            html += '<th style="border: 1px solid #ddd; padding: 8px;">Blade 2 Thrust</th>';
            html += '<th style="border: 1px solid #ddd; padding: 8px;">|Diff|</th>';
            html += '</tr></thead><tbody>';
            
            debugData.forEach((row, idx) => {
                const bgColor = idx % 2 === 0 ? '#f9f9f9' : '#ffffff';
                html += `<tr style="background: ${bgColor};">`;
                html += `<td style="border: 1px solid #ddd; padding: 6px; text-align: center;">${row.angle.toFixed(0)}¬∞</td>`;
                html += `<td style="border: 1px solid #ddd; padding: 6px; text-align: center;">${row.azimuth1Deg.toFixed(1)}¬∞</td>`;
                html += `<td style="border: 1px solid #ddd; padding: 6px; text-align: center; font-size: 0.8em;">${row.pos1}</td>`;
                html += `<td style="border: 1px solid #ddd; padding: 6px; text-align: right; font-weight: bold;">${row.thrust1.toFixed(3)}</td>`;
                html += `<td style="border: 1px solid #ddd; padding: 6px; text-align: center;">${row.azimuth2Deg.toFixed(1)}¬∞</td>`;
                html += `<td style="border: 1px solid #ddd; padding: 6px; text-align: center; font-size: 0.8em;">${row.pos2}</td>`;
                html += `<td style="border: 1px solid #ddd; padding: 6px; text-align: right; font-weight: bold;">${row.thrust2.toFixed(3)}</td>`;
                html += `<td style="border: 1px solid #ddd; padding: 6px; text-align: right; color: ${row.diff < 0.1 ? 'green' : 'black'};">${row.diff.toFixed(3)}</td>`;
                html += '</tr>';
            });
            
            html += '</tbody></table>';
            
            // Add crossings info
            html += '<h3 style="margin-top: 20px;">Crossings (where Thrust1 ‚âà Thrust2)</h3>';
            if (turbineParams.yawAngle === 0 && turbineParams.inflowAngle === 0) {
                html += '<p><strong>Expected with no yaw/inflow:</strong> Thrusts should be equal everywhere (constant), so any "crossings" are numerical artifacts.</p>';
            } else {
                html += '<p><strong>Expected with yaw or inflow:</strong> Crossings at 90¬∞ and 270¬∞ (advancing/retreating sides)</p>';
            }
            if (crossings.length > 0) {
                html += '<ul>';
                crossings.forEach((cross, idx) => {
                    const expected = 90 + idx * 180;
                    const error = cross.angle - expected;
                    html += `<li>Crossing ${idx+1}: <strong>${cross.angle.toFixed(2)}¬∞</strong> (thrust=${cross.thrust.toFixed(3)}) - Expected: ${expected}¬∞ - <span style="color: ${Math.abs(error) < 5 ? 'green' : 'red'};">Error: ${error.toFixed(2)}¬∞</span></li>`;
                });
                html += '</ul>';
            } else {
                html += '<p style="color: red;">No crossings found!</p>';
            }
            
            // Fourier Analysis
            html += '<h3 style="margin-top: 30px;">Fourier Analysis (Harmonics)</h3>';
            html += '<p>Decomposition into 0P (mean), 1P, 2P, 3P, and 4P harmonics</p>';
            
            // Extract one full revolution for each blade
            const blade1Thrust = [];
            const blade2Thrust = [];
            const blade1MomentY = [];
            const blade2MomentY = [];
            const blade1MomentZ = [];
            const blade2MomentZ = [];
            
            for (let i = 0; i < 36; i++) { // 0-360 degrees in 10-degree steps
                const row = debugData[i];
                blade1Thrust.push(row.thrust1);
                blade2Thrust.push(row.thrust2);
                
                // Calculate moments (same as in updatePlotData)
                const azimuth1 = row.azimuth1Deg * Math.PI / 180;
                const azimuth2 = row.azimuth2Deg * Math.PI / 180;
                const r = targetRadius;
                
                blade1MomentY.push(row.thrust1 * r * Math.sin(azimuth1));
                blade1MomentZ.push(-row.thrust1 * r * Math.cos(azimuth1));
                blade2MomentY.push(row.thrust2 * r * Math.sin(azimuth2));
                blade2MomentZ.push(-row.thrust2 * r * Math.cos(azimuth2));
            }
            
            // Perform Fourier analysis
            const blade1ThrustFourier = analyzeFourier(blade1Thrust);
            const blade2ThrustFourier = analyzeFourier(blade2Thrust);
            const blade1MomentYFourier = analyzeFourier(blade1MomentY);
            const blade2MomentYFourier = analyzeFourier(blade2MomentY);
            const blade1MomentZFourier = analyzeFourier(blade1MomentZ);
            const blade2MomentZFourier = analyzeFourier(blade2MomentZ);
            
            // Display results
            html += '<h4>Blade 1 Thrust</h4>';
            html += '<table style="border-collapse: collapse; font-size: 0.9em; margin-bottom: 15px;">';
            html += '<thead><tr style="background: #667eea; color: white;">';
            html += '<th style="border: 1px solid #ddd; padding: 6px;">Harmonic</th>';
            html += '<th style="border: 1px solid #ddd; padding: 6px;">Amplitude</th>';
            html += '<th style="border: 1px solid #ddd; padding: 6px;">Phase (deg)</th>';
            html += '</tr></thead><tbody>';
            blade1ThrustFourier.forEach((h, idx) => {
                const bgColor = idx % 2 === 0 ? '#f9f9f9' : '#ffffff';
                html += `<tr style="background: ${bgColor};">`;
                html += `<td style="border: 1px solid #ddd; padding: 6px; text-align: center;">${h.harmonic}P</td>`;
                html += `<td style="border: 1px solid #ddd; padding: 6px; text-align: right;">${h.amplitude.toFixed(3)}</td>`;
                html += `<td style="border: 1px solid #ddd; padding: 6px; text-align: right;">${h.phase.toFixed(1)}¬∞</td>`;
                html += '</tr>';
            });
            html += '</tbody></table>';
            
            html += '<h4>Blade 2 Thrust</h4>';
            html += '<table style="border-collapse: collapse; font-size: 0.9em; margin-bottom: 15px;">';
            html += '<thead><tr style="background: #667eea; color: white;">';
            html += '<th style="border: 1px solid #ddd; padding: 6px;">Harmonic</th>';
            html += '<th style="border: 1px solid #ddd; padding: 6px;">Amplitude</th>';
            html += '<th style="border: 1px solid #ddd; padding: 6px;">Phase (deg)</th>';
            html += '</tr></thead><tbody>';
            blade2ThrustFourier.forEach((h, idx) => {
                const bgColor = idx % 2 === 0 ? '#f9f9f9' : '#ffffff';
                html += `<tr style="background: ${bgColor};">`;
                html += `<td style="border: 1px solid #ddd; padding: 6px; text-align: center;">${h.harmonic}P</td>`;
                html += `<td style="border: 1px solid #ddd; padding: 6px; text-align: right;">${h.amplitude.toFixed(3)}</td>`;
                html += `<td style="border: 1px solid #ddd; padding: 6px; text-align: right;">${h.phase.toFixed(1)}¬∞</td>`;
                html += '</tr>';
            });
            html += '</tbody></table>';
            
            html += '<h4>Blade 1 Yawing Moment (M_y)</h4>';
            html += '<table style="border-collapse: collapse; font-size: 0.9em; margin-bottom: 15px;">';
            html += '<thead><tr style="background: #667eea; color: white;">';
            html += '<th style="border: 1px solid #ddd; padding: 6px;">Harmonic</th>';
            html += '<th style="border: 1px solid #ddd; padding: 6px;">Amplitude</th>';
            html += '<th style="border: 1px solid #ddd; padding: 6px;">Phase (deg)</th>';
            html += '</tr></thead><tbody>';
            blade1MomentYFourier.forEach((h, idx) => {
                const bgColor = idx % 2 === 0 ? '#f9f9f9' : '#ffffff';
                html += `<tr style="background: ${bgColor};">`;
                html += `<td style="border: 1px solid #ddd; padding: 6px; text-align: center;">${h.harmonic}P</td>`;
                html += `<td style="border: 1px solid #ddd; padding: 6px; text-align: right;">${h.amplitude.toFixed(3)}</td>`;
                html += `<td style="border: 1px solid #ddd; padding: 6px; text-align: right;">${h.phase.toFixed(1)}¬∞</td>`;
                html += '</tr>';
            });
            html += '</tbody></table>';
            
            html += '<h4>Blade 1 Nodding Moment (M_z)</h4>';
            html += '<table style="border-collapse: collapse; font-size: 0.9em; margin-bottom: 15px;">';
            html += '<thead><tr style="background: #667eea; color: white;">';
            html += '<th style="border: 1px solid #ddd; padding: 6px;">Harmonic</th>';
            html += '<th style="border: 1px solid #ddd; padding: 6px;">Amplitude</th>';
            html += '<th style="border: 1px solid #ddd; padding: 6px;">Phase (deg)</th>';
            html += '</tr></thead><tbody>';
            blade1MomentZFourier.forEach((h, idx) => {
                const bgColor = idx % 2 === 0 ? '#f9f9f9' : '#ffffff';
                html += `<tr style="background: ${bgColor};">`;
                html += `<td style="border: 1px solid #ddd; padding: 6px; text-align: center;">${h.harmonic}P</td>`;
                html += `<td style="border: 1px solid #ddd; padding: 6px; text-align: right;">${h.amplitude.toFixed(3)}</td>`;
                html += `<td style="border: 1px solid #ddd; padding: 6px; text-align: right;">${h.phase.toFixed(1)}¬∞</td>`;
                html += '</tr>';
            });
            html += '</tbody></table>';
            
            output.innerHTML = html;
        }
        
        // Perform DFT analysis on a signal
        function analyzeFourier(signal, maxHarmonic = 4) {
            const N = signal.length;
            const results = [];
            
            for (let k = 0; k <= maxHarmonic; k++) {
                let real = 0;
                let imag = 0;
                
                for (let n = 0; n < N; n++) {
                    const angle = (2 * Math.PI * k * n) / N;
                    real += signal[n] * Math.cos(angle);
                    imag += signal[n] * Math.sin(angle);
                }
                
                real /= N;
                imag /= N;
                
                // For k > 0, multiply by 2 to get amplitude (since we only look at positive frequencies)
                const amplitude = k === 0 ? real : 2 * Math.sqrt(real * real + imag * imag);
                const phase = Math.atan2(imag, real) * 180 / Math.PI;
                
                results.push({
                    harmonic: k,
                    amplitude: amplitude,
                    phase: phase,
                    real: real,
                    imag: imag
                });
            }
            
            return results;
        }
        
        // Helper to describe blade position
        function getPositionDescription(azimuthDeg) {
            if (azimuthDeg < 45 || azimuthDeg >= 315) return '‚Üë Top';
            if (azimuthDeg >= 45 && azimuthDeg < 135) return '‚Üí Adv';
            if (azimuthDeg >= 135 && azimuthDeg < 225) return '‚Üì Bot';
            return '‚Üê Ret';
        }
        
        // Helper function to calculate thrust at a given azimuth
        function calculateThrustAtAzimuth(azimuth, r, chord, omega, windSpeedAxial, windSpeedTangential, inflowRadians) {
            // Blade twist distribution (typical for wind turbine)
            const r_norm = (r - turbineParams.hubRadius) / (turbineParams.bladeRadius - turbineParams.hubRadius);
            const twist = 14 * (1 - r_norm); // Linear twist from 14¬∞ at root to 0¬∞ at tip
            
            // Velocities in rotor disc coordinates
            // Use proper coordinate transformation
            const V = turbineParams.windSpeed;
            const alpha = inflowRadians;
            const beta = turbineParams.yawAngle * Math.PI / 180;
            
            const V_x = V * Math.sin(beta);
            const V_y = V * Math.sin(alpha) * Math.cos(beta);
            const V_z = V * Math.cos(alpha) * Math.cos(beta);
            
            // In-plane velocity component at blade azimuth (perpendicular to radius)
            const V_inplane_tangential = V_x * Math.cos(azimuth) - V_y * Math.sin(azimuth);
            
            // Tangential velocity (rotation + in-plane wind)
            const Vt = omega * r + V_inplane_tangential;
            
            // Normal velocity (axial wind + induction)
            const Vn = -V_z * (1 - 0.3);
            
            // Flow angle and angle of attack
            const phi = Math.atan2(Vn, Vt);
            const aoa = -(phi * 180 / Math.PI - twist + turbineParams.bladePitch);
            
            // Dynamic pressure
            const V_total = Math.sqrt(Vt * Vt + Vn * Vn);
            const q = 0.5 * 1.225 * V_total * V_total * chord * (turbineParams.bladeRadius / 100);
            
            // Simple aerodynamic model
            const Cl = 2 * Math.PI * Math.sin(aoa * Math.PI / 180);
            const L = q * Cl;
            const D = 0.05 * Math.abs(L);
            
            // Thrust (axial force)
            const thrust = L * Math.cos(phi) + D * Math.sin(phi);
            return thrust;
        }
        
        // Make panels draggable (only by their headers)
        function makeDraggable(element, handleSelector) {
            let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
            
            // Get the header element if selector provided, otherwise use the whole element
            const handle = handleSelector ? element.querySelector(handleSelector) : element;
            
            if (handle) {
                handle.onmousedown = dragMouseDown;
                handle.style.cursor = 'move';
            }
            
            function dragMouseDown(e) {
                // Don't drag if clicking on a button
                if (e.target.tagName === 'BUTTON') {
                    return;
                }
                e.preventDefault();
                pos3 = e.clientX;
                pos4 = e.clientY;
                document.onmouseup = closeDragElement;
                document.onmousemove = elementDrag;
            }
            
            function elementDrag(e) {
                e.preventDefault();
                pos1 = pos3 - e.clientX;
                pos2 = pos4 - e.clientY;
                pos3 = e.clientX;
                pos4 = e.clientY;
                element.style.top = (element.offsetTop - pos2) + "px";
                element.style.left = (element.offsetLeft - pos1) + "px";
            }
            
            function closeDragElement() {
                document.onmouseup = null;
                document.onmousemove = null;
            }
        }
        
        makeDraggable(document.getElementById('controls-panel'), '.panel-header');
        makeDraggable(document.getElementById('stats'), 'h3');
        makeDraggable(document.getElementById('legend'), 'h3');
        makeDraggable(document.getElementById('plot-panel'), '.plot-header');
        
        // Minimize controls panel
        document.getElementById('minimize-btn').addEventListener('click', () => {
            const panel = document.getElementById('controls-panel');
            const btn = document.getElementById('minimize-btn');
            panel.classList.toggle('minimized');
            btn.textContent = panel.classList.contains('minimized') ? '+' : '‚àí';
        });
        
        // Minimize plot panel
        document.getElementById('minimize-plot-btn').addEventListener('click', () => {
            const panel = document.getElementById('plot-panel');
            const btn = document.getElementById('minimize-plot-btn');
            panel.classList.toggle('minimized');
            btn.textContent = panel.classList.contains('minimized') ? '+' : '‚àí';
        });
        
        // Tab switching for traces
        document.querySelectorAll('.trace-tab-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const tabName = btn.getAttribute('data-tab');
                
                // Update button states
                document.querySelectorAll('.trace-tab-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                // Update tab content visibility
                document.querySelectorAll('.trace-tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                document.getElementById(tabName + '-tab').classList.add('active');
                
                // Force chart resize when switching tabs
                setTimeout(() => {
                    if (tabName === 'thrust' && typeof liftChart !== 'undefined') {
                        liftChart.resize();
                    } else if (tabName === 'moment-y' && typeof momentYChart !== 'undefined') {
                        momentYChart.resize();
                    } else if (tabName === 'moment-z' && typeof momentZChart !== 'undefined') {
                        momentZChart.resize();
                    }
                }, 100);
            });
        });
        
        // Window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            if (composer){
                composer.setSize(window.innerWidth, window.innerHeight);
                if (fxaaPass){
                    fxaaPass.material.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight);
                }
            }
        });
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Update blade loads BEFORE rotating (so loads match current position)
            updateBladeLoads();
            
            // Rotate rotor AFTER calculating loads (only if not paused)
            if (!turbineParams.paused) {
                // Apply speed multiplier during fast Fourier collection
                const speedMultiplier = (fourierData.collecting && fourierData.fastMode) ? fourierData.speedMultiplier : 1;
                const deltaRotation = (turbineParams.shaftSpeed * 2 * Math.PI) / (60 * 60) * speedMultiplier; // per frame at 60fps
                rotorGroup.rotation.x += deltaRotation;
            }
            
            // Keep sky centered on camera in photo mode
            if (isPhotoMode && skyboxMesh) {
                skyboxMesh.position.copy(camera.position);
                
                // Adjust material env map intensity based on distance
                const camDist = camera.position.length();
                const intensityScale = THREE.MathUtils.clamp(camDist / 50, 0.6, 1.5);
                bladeSegments.forEach(seg => {
                    if (seg.material.envMapIntensity !== undefined) {
                        seg.material.envMapIntensity = intensityScale;
                    }
                });
            }
            
            controls.update();
            if (composer && isPhotoMode) composer.render(); else renderer.render(scene, camera);
        }
        
        // Optional cinematic zoom on key 'z'
        function ease(t){ return t<.5 ? 2*t*t : -1+(4-2*t)*t; }
        function cinematicZoom(targetPos, lookAt, duration=1200){
            const start = performance.now();
            const startPos = camera.position.clone();
            const startExp = renderer.toneMappingExposure;
            const startFocus = bokehPass ? bokehPass.materialBokeh.uniforms['focus'].value : PhotoConfig.bokehFocusFar;
            const endFocus = PhotoConfig.bokehFocusNear;
            const endExp = 1.25;

            function step(now){
                const t = Math.min(1, (now-start)/duration), k = ease(t);
                camera.position.lerpVectors(startPos, targetPos, k);
                controls.target.lerp(lookAt, k);
                if (isPhotoMode){
                    renderer.toneMappingExposure = THREE.MathUtils.lerp(startExp, endExp, k);
                    if (bokehPass) bokehPass.materialBokeh.uniforms['focus'].value =
                        THREE.MathUtils.lerp(startFocus, endFocus, k);
                }
                if (t<1) requestAnimationFrame(step);
            }
            requestAnimationFrame(step);
        }
        document.addEventListener('keydown', (e)=>{
            if (e.key==='z' && hub){
                const p = new THREE.Vector3(); hub.getWorldPosition(p);
                cinematicZoom(p.clone().add(new THREE.Vector3(6,2,6)), p);
            }
        });
        
        animate();
    </script>


</body></html>
